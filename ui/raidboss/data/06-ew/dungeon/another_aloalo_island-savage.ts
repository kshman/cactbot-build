// This file was autogenerated from running ts-node util/sync_files.ts.
// DO NOT EDIT THIS FILE DIRECTLY.

import Conditions from '../../../../../resources/conditions';
import Outputs from '../../../../../resources/outputs';
import { Responses } from '../../../../../resources/responses';
import ZoneId from '../../../../../resources/zone_id';
import { RaidbossData } from '../../../../../types/data';
import { PluginCombatantState } from '../../../../../types/event';
import { NetMatches } from '../../../../../types/net_matches';
import { PartyMemberParamObject } from '../../../../../types/party';
import { Output, TriggerSet } from '../../../../../types/trigger';

type ClockRotate = 'cw' | 'ccw' | 'unknown';
type MarchDirection = 'front' | 'back' | 'left' | 'right' | 'unknown';

const ForceMoveStrings = {
  stack: Outputs.getTogether,
  spread: Outputs.spread,
  forward: {
    en: 'ê°•ì œì´ë™: ì• ğŸ¡º ${aim}',
  },
  backward: {
    en: 'ê°•ì œì´ë™: ë’¤ ğŸ¡º ${aim}',
  },
  left: {
    en: 'ê°•ì œì´ë™: ì™¼ìª½ ğŸ¡º ${aim}',
  },
  right: {
    en: 'ê°•ì œì´ë™: ì˜¤ë¥¸ìª½ ğŸ¡º ${aim}',
  },
  move: {
    en: 'ê°•ì œì´ë™ ğŸ¡º ${aim}',
  },
  safety: {
    en: 'ì•ˆì „í•œ ê³³',
  },
} as const;

export interface Data extends RaidbossData {
  ketuCrystalAdd: NetMatches['AddedCombatant'][];
  ketuSpringCrystalCount: number;
  ketuHydroCount: number;
  ketuHydroStack?: NetMatches['GainsEffect'];
  ketuHydroSpread?: NetMatches['GainsEffect'];
  ketuEffectId?: string;
  lalaBlight: MarchDirection;
  lalaRotate: ClockRotate;
  lalaCount: number;
  lalaSubtractive: number;
  lalaMyMarch: MarchDirection;
  lalaMyRotate: ClockRotate;
  lalaMyCount: number;
  stcReloadCount: number;
  stcReloadFailed: number;
  stcRingRing: number;
  stcBullsEyes: PartyMemberParamObject[];
  stcClaws: string[];
  stcMissiles: string[];
  stcSeenPinwheeling: boolean;
  stcAdjustBullsEye: boolean;
  stcTether: boolean;
  stcChains: string[];
  stcBallFire?: number;
  stcPop: number;
  stcMyMarch: MarchDirection;
  stcMyDuration: number;
  gainList: NetMatches['GainsEffect'][];
  isStackFirst: boolean;
  //
  readonly triggerSetConfig: {
    stackOrder: 'meleeRolesPartners' | 'rolesPartners';
  };
  combatantData: PluginCombatantState[];
}

// Horizontal crystals have a heading of 0, vertical crystals are -pi/2.
const isHorizontalCrystal = (line: NetMatches['AddedCombatant']) => {
  const epsilon = 0.1;
  return Math.abs(parseFloat(line.heading)) < epsilon;
};

// ìŠ¤íƒ ë¨¼ì €?
const isStackFirst = (
  stack?: NetMatches['GainsEffect'],
  spread?: NetMatches['GainsEffect'],
): boolean => {
  if (stack === undefined)
    return false;
  const stackTime = parseFloat(stack.duration);
  if (spread === undefined)
    return true;
  const spreadTime = parseFloat(spread.duration);
  return stackTime < spreadTime;
};

// ë¦¬ë²„ìŠ¤?
const isReverseRotate = (rot: ClockRotate, count: number): boolean => {
  if (rot === 'cw' && count === 3)
    return true;
  if (rot === 'ccw' && (count === 0 || count === 5))
    return true;
  return false;
};

// ìŠ¤íƒ€í‹°ìŠ¤ ë‚˜ëˆ”
const stcBallOfFire = (combatant: NetMatches['AddedCombatant']): number => {
  const hg = parseFloat(combatant.heading);
  return (Math.round(6 - 6 * (2 * Math.PI - hg) / Math.PI) % 12 + 12) % 12;
};

// ì£¼ì‚¬ìœ„ë¥¼ ë§ˆì»¤ë¡œ
const diceToMarker = (no: number): string => {
  const diceMap: { [dice: number]: string } = {
    1: 'â’¶',
    2: 'â‘ ',
    3: 'â‘¡',
    4: 'â’¸',
    5: 'â‘¢',
    6: 'â‘£',
  } as const;
  const ret = diceMap[no];
  return ret === undefined ? 'ëª°?ë£¨' : ret;
};

// ê°•ì œ ì´ë™
const forceMove = (
  output: Output,
  march: MarchDirection,
  stackFirst?: boolean,
  safezone?: string,
): string => {
  if (march !== undefined) {
    const move = {
      'front': output.forward,
      'back': output.backward,
      'left': output.left,
      'right': output.right,
      'unknown': output.move,
    }[march];
    if (safezone !== undefined)
      return move!({ aim: safezone });
    return move!({ aim: stackFirst ? output.stack!() : output.spread!() });
  }
  if (safezone !== undefined)
    return safezone;
  if (stackFirst)
    return output.stack!();
  return output.spread!();
};

const triggerSet: TriggerSet<Data> = {
  id: 'AnotherAloaloIslandSavage',
  zoneId: ZoneId.AnotherAloaloIslandSavage,
  timelineFile: 'another_aloalo_island-savage.txt',
  initData: () => {
    return {
      ketuCrystalAdd: [],
      ketuSpringCrystalCount: 0,
      ketuHydroCount: 0,
      lalaBlight: 'unknown',
      lalaRotate: 'unknown',
      lalaCount: 0,
      lalaSubtractive: 0,
      lalaMyMarch: 'unknown',
      lalaMyRotate: 'unknown',
      lalaMyCount: 0,
      stcReloadCount: 0,
      stcReloadFailed: 0,
      stcRingRing: 0,
      stcBullsEyes: [],
      stcClaws: [],
      stcMissiles: [],
      stcSeenPinwheeling: false,
      stcAdjustBullsEye: false,
      stcTether: false,
      stcChains: [],
      stcPop: 0,
      stcMyMarch: 'unknown',
      stcMyDuration: 0,
      gainList: [],
      isStackFirst: false,
      //
      combatantData: [],
    };
  },
  triggers: [
    // ---------------- first trash ----------------
    {
      id: 'AAIS Kiwakin Lead Hook',
      type: 'StartsUsing',
      netRegex: { id: '8BC7', source: 'Aloalo Kiwakin' },
      response: (data, matches, output) => {
        // cactbot-builtin-response
        output.responseOutputStrings = {
          tankBusterOnYou: {
            en: 'ë‚´ê²Œ 3ì—°ì† íƒ±í¬ë²„ìŠ¤í„°',
          },
          tankBusterOnPlayer: {
            en: '3ì—°ì† íƒ±í¬ë²„ìŠ¤í„°: ${player}',
          },
        };

        if (matches.target === data.me)
          return { alertText: output.tankBusterOnYou!() };
        const target = data.party.member(matches.target);
        return { infoText: output.tankBusterOnPlayer!({ player: target }) };
      },
    },
    {
      id: 'AAIS Kiwakin Sharp Strike',
      type: 'StartsUsing',
      netRegex: { id: '8BC8', source: 'Aloalo Kiwakin' },
      response: Responses.tankBuster(),
    },
    {
      id: 'AAIS Kiwakin Tail Screw',
      type: 'StartsUsing',
      // This is a baited targeted circle.
      netRegex: { id: '8BC9', source: 'Aloalo Kiwakin', capture: false },
      response: Responses.moveAway(),
    },
    {
      id: 'AAIS Snipper Water III',
      type: 'StartsUsing',
      netRegex: { id: '8BCC', source: 'Aloalo Snipper' },
      response: Responses.stackMarkerOn(),
    },
    {
      id: 'AAIS Snipper Bubble Shower',
      type: 'StartsUsing',
      netRegex: { id: '8BCA', source: 'Aloalo Snipper', capture: false },
      infoText: (_data, _matches, output) => output.text!(),
      outputStrings: {
        text: 'ì˜†ìœ¼ë¡œ (ì•=>ë’¤ ê³µê²©)',
      },
    },
    {
      id: 'AAIS Snipper Crab Dribble',
      type: 'Ability',
      // Crab Dribble 8BCB has a fast cast, so trigger on Bubble Shower ability
      netRegex: { id: '8BCA', source: 'Aloalo Snipper', capture: false },
      response: Responses.goFront('info'),
    },
    {
      id: 'AAIS Ray Hydrocannon',
      type: 'StartsUsing',
      netRegex: { id: '8C4B', source: 'Aloalo Ray', capture: false },
      response: Responses.getBehind(),
    },
    {
      id: 'AAIS Ray Expulsion',
      type: 'StartsUsing',
      netRegex: { id: '8BCE', source: 'Aloalo Ray', capture: false },
      response: Responses.getOut(),
    },
    {
      id: 'AAIS Ray Electric Whorl',
      type: 'StartsUsing',
      netRegex: { id: '8BCD', source: 'Aloalo Ray', capture: false },
      response: Responses.getUnder('alert'),
    },
    {
      id: 'AAIS Monk Hydroshot',
      type: 'StartsUsing',
      netRegex: { id: '8BD1', source: 'Aloalo Monk' },
      condition: Conditions.targetIsYou(),
      response: Responses.knockbackOn(),
    },
    {
      id: 'AAIS Monk Cross Attack',
      type: 'StartsUsing',
      netRegex: { id: '8C4F', source: 'Aloalo Monk' },
      response: Responses.tankBuster(),
    },
    // ---------------- Ketuduke ----------------
    {
      id: 'AAIS Ketuduke Tidal Roar',
      type: 'StartsUsing',
      netRegex: { id: '8AD4', source: 'Ketuduke', capture: false },
      response: Responses.bleedAoe(),
    },
    {
      id: 'AAIS Ketuduke Bubble Net',
      type: 'StartsUsing',
      netRegex: { id: '8AAD', source: 'Ketuduke', capture: false },
      response: Responses.aoe(),
    },
    {
      id: 'AAIS Ketuduke Spring Crystals',
      type: 'StartsUsing',
      netRegex: { id: '8AA8', source: 'Ketuduke', capture: false },
      run: (data) => {
        data.ketuSpringCrystalCount++;
        data.ketuCrystalAdd = [];
      },
    },
    {
      id: 'AAIS Ketuduke Spring Crystal 1 Collect',
      type: 'AddedCombatant',
      netRegex: { npcNameId: '12606' }, // ë™ê¸€
      run: (data, matches) => data.ketuCrystalAdd.push(matches),
    },
    {
      id: 'AAIS Ketuduke Spring Crystal 2 Collect',
      type: 'AddedCombatant',
      netRegex: { npcNameId: '12607' }, // ë„¤ëª¨
      run: (data, matches) => data.ketuCrystalAdd.push(matches),
    },
    {
      id: 'AAIS Ketuduke Bubble Weave/Foamy Fetters',
      type: 'GainsEffect',
      netRegex: { effectId: ['E9F', 'ECC'] },
      infoText: (data, matches, output) => {
        if (data.me !== matches.target)
          return;
        data.ketuEffectId = matches.effectId;
        if (matches.effectId === 'E9F')
          return output.bubble!();
        return output.bind!();
      },
      run: (data, matches) => data.gainList.push(matches),
      outputStrings: {
        bubble: 'ğŸ”µë²„ë¸”',
        bind: 'ğŸŸ¡ë°”ì¸ë“œ',
      },
    },
    {
      id: 'AAIS Ketuduke Hydrofall Target',
      type: 'GainsEffect',
      netRegex: { effectId: 'EA3' },
      run: (data, matches) => data.ketuHydroStack = matches,
    },
    {
      id: 'AAIS Ketuduke Hydrobullet Target',
      type: 'GainsEffect',
      netRegex: { effectId: 'EA4' },
      run: (data, matches) => data.ketuHydroSpread = matches,
    },
    {
      id: 'AAIS Ketuduke Fluke Gale Hydro',
      type: 'GainsEffect',
      netRegex: { effectId: ['EA3', 'EA4'] },
      condition: (data) => data.ketuHydroCount === 0 || data.ketuHydroCount === 5,
      delaySeconds: 0.5,
      suppressSeconds: 2,
      infoText: (_data, matches, output) => {
        if (matches.effectId === 'EA3')
          return output.stack!();
        return output.spread!();
      },
      run: (data) => data.ketuHydroCount++,
      outputStrings: {
        spread: Outputs.spread,
        stack: Outputs.pairStack,
      },
    },
    {
      id: 'AAIS Ketuduke Fluke Gale',
      type: 'Ability',
      netRegex: { id: '8AB1', source: 'Ketuduke', capture: false },
      durationSeconds: 8,
      alertText: (data, _matches, output) => {
        data.isStackFirst = isStackFirst(data.ketuHydroStack, data.ketuHydroSpread);
        if (data.ketuEffectId !== 'E9F' && !data.isStackFirst)
          return output.go2!();
        return output.go1!();
      },
      run: (data) => delete data.ketuEffectId,
      outputStrings: {
        go1: {
          en: '1ë²ˆ ì¹¸ìœ¼ë¡œ',
        },
        go2: {
          en: '2ë²ˆ ì¹¸ìœ¼ë¡œ',
        },
      },
    },
    {
      id: 'AAIS Ketuduke Blowing Bubbles',
      type: 'GainsEffect',
      netRegex: { effectId: ['EA3', 'EA4'], capture: false },
      condition: (data) => data.ketuHydroCount === 1,
      delaySeconds: 4,
      durationSeconds: 8,
      suppressSeconds: 999999,
      alertText: (data, _matches, output) => {
        data.isStackFirst = isStackFirst(data.ketuHydroStack, data.ketuHydroSpread);
        return data.isStackFirst ? output.stacks!() : output.spread!();
      },
      run: (data) => data.ketuHydroCount = 2,
      outputStrings: {
        stacks: {
          en: 'ë­‰ì³¤ë‹¤ => í©ì–´ì ¸ìš”',
        },
        spread: {
          en: 'í©ì–´ì¡Œë‹¤ => ë­‰ì³ìš”',
        },
      },
    },
    {
      id: 'AAIS Ketuduke Blowing Bubbles Stack Reminder',
      type: 'GainsEffect',
      netRegex: { effectId: 'EA3' },
      condition: (data) => data.ketuHydroCount === 1,
      delaySeconds: (_data, matches) => parseFloat(matches.duration) - 5,
      suppressSeconds: 999999,
      alertText: (data, _matches, output) => {
        if (!data.isStackFirst)
          return output.pairStack!();
      },
      outputStrings: {
        pairStack: Outputs.pairStack,
      },
    },
    {
      id: 'AAIS Ketuduke Blowing Bubbles Spread Reminder',
      type: 'GainsEffect',
      netRegex: { effectId: 'EA4' },
      condition: (data) => data.ketuHydroCount === 1,
      delaySeconds: (_data, matches) => parseFloat(matches.duration) - 5,
      suppressSeconds: 999999,
      alertText: (data, _matches, output) => {
        if (data.isStackFirst)
          return output.spread!();
      },
      outputStrings: {
        spread: Outputs.spread,
      },
    },
    {
      id: 'AAIS Ketuduke Twintides Hydrofall Target',
      type: 'GainsEffect',
      netRegex: { effectId: 'EA3', capture: false },
      condition: (data) => data.ketuHydroCount === 2,
      run: (data) => {
        data.ketuHydroCount = 3;
        data.gainList = []; // Roarìš© ì‚¬ëŒ ì°¾ê¸° ë¦¬ì…‹
      },
    },
    {
      id: 'AAIS Ketuduke Receding Twintides',
      type: 'StartsUsing',
      netRegex: { id: '8AE7', source: 'Ketuduke', capture: false },
      alertText: (_data, _matches, output) => output.text!(),
      outputStrings: {
        text: {
          en: 'ë°–ì— ìˆë‹¤ => ì•ˆì—ì„œ í˜ì–´',
        },
      },
    },
    {
      id: 'AAIS Ketuduke Encroaching Twintides',
      type: 'StartsUsing',
      netRegex: { id: '8AE9', source: 'Ketuduke', capture: false },
      alertText: (_data, _matches, output) => output.text!(),
      outputStrings: {
        text: {
          en: 'ì•ˆì— ìˆë‹¤ => ë°–ì—ì„œ í˜ì–´',
        },
      },
    },
    {
      id: 'AAIS Ketuduke Spring Crystals 2',
      type: 'AddedCombatant',
      netRegex: { npcNameId: '12607', capture: false },
      condition: (data) => data.ketuSpringCrystalCount === 2 && data.ketuCrystalAdd.length === 4,
      alertText: (data, _matches, output) => {
        const horizontal = data.ketuCrystalAdd.filter((x) => isHorizontalCrystal(x));
        const vertical = data.ketuCrystalAdd.filter((x) => !isHorizontalCrystal(x));
        if (horizontal.length !== 2 || vertical.length !== 2)
          return;

        // Crystal positions are always -15, -5, 5, 15.

        // Check if any verticals are on the outer vertical edges.
        for (const line of vertical) {
          const y = parseFloat(line.y);
          if (y < -10 || y > 10)
            return output.eastWestSafe!();
        }

        // Check if any horizontals are on the outer horizontal edges.
        for (const line of horizontal) {
          const x = parseFloat(line.x);
          if (x < -10 || x > 10)
            return output.northSouthSafe!();
        }

        return output.cornersSafe!();
      },
      outputStrings: {
        northSouthSafe: {
          en: 'ì•ˆì „: ë‚¨ë¶',
        },
        eastWestSafe: {
          en: 'ì•ˆì „: ë™ì„œ',
        },
        cornersSafe: {
          en: 'ì•ˆì „: ëª¨ì„œë¦¬',
        },
      },
    },
    {
      id: 'AAIS Ketuduke Roar Search',
      type: 'GainsEffect',
      netRegex: { effectId: 'EA4' },
      condition: (data) => data.ketuHydroCount === 3,
      delaySeconds: (_data, matches) => parseFloat(matches.duration) - 10,
      durationSeconds: 8,
      suppressSeconds: 999999,
      alertText: (data, _matches, output) => {
        const [player] = data.gainList.filter((x) =>
          x.effectId === data.ketuEffectId && x.target !== data.me
        ).map((x) => data.party.member(x.target).ajob);
        if (data.ketuEffectId === 'E9F')
          return output.bubble!({ player: player });
        return output.bind!({ player: player });
      },
      run: (data) => {
        delete data.ketuEffectId;
        data.ketuHydroCount = 4;
        data.gainList = [];
      },
      outputStrings: {
        bubble: 'ë°”ë‹¥ ì«„(${player}) => ìê¸° ìë¦¬ë¡œ',
        bind: 'ë²„ë¸”(${player}) => ìê¸° ìë¦¬ë¡œ',
      },
    },
    {
      id: 'AAIS Ketuduke Roar Move',
      type: 'StartsUsing',
      netRegex: { id: '8ADC', source: 'Spring Crystal', capture: false },
      condition: (data) => data.ketuHydroCount === 4, // 3ì´ ì•„ë‹ê»„
      suppressSeconds: 2,
      alertText: (_data, _matches, output) => output.text!(),
      outputStrings: {
        text: {
          en: 'ì«„ ë’¤ë¡œ!',
        },
      },
    },
    {
      id: 'AAIS Ketuduke Angry Seas Hydro',
      type: 'GainsEffect',
      netRegex: { effectId: ['EA3', 'EA4'], capture: false },
      condition: (data) => data.ketuHydroCount === 4,
      delaySeconds: 4.5,
      suppressSeconds: 999999,
      alertText: (data, _matches, output) => {
        data.isStackFirst = isStackFirst(data.ketuHydroStack, data.ketuHydroSpread);
        return data.isStackFirst ? output.stack!() : output.spread!();
      },
      run: (data) => data.ketuHydroCount = 5,
      outputStrings: {
        stack: {
          en: 'ë­‰ì³¤ë‹¤ => í©ì–´ì ¸ìš”',
        },
        spread: {
          en: 'í©ì–´ì¡Œë‹¤ => ë­‰ì³ìš”',
        },
      },
    },
    {
      id: 'AAIS Ketuduke Angry Seas',
      type: 'StartsUsing',
      netRegex: { id: '8AE1', source: 'Ketuduke', capture: false },
      alertText: (_data, _matches, output) => output.text!(),
      outputStrings: {
        text: {
          en: 'ë„‰ë°±! ì €í•­í•˜ë¼!!!',
        },
      },
    },
    {
      id: 'AAIS Ketuduke Fluke Typhoon Bubble',
      type: 'StartsUsing',
      netRegex: { id: '8AAF', source: 'Ketuduke', capture: false },
      condition: (data) => data.role === 'dps',
      infoText: (data, _matches, output) => {
        if (data.ketuCrystalAdd.length !== 4 || data.ketuCrystalAdd[0] === undefined)
          return output.text!();
        if (parseFloat(data.ketuCrystalAdd[0].x) < 0)
          return output.left!();
        return output.right!();
      },
      run: (data) => data.ketuCrystalAdd = [],
      outputStrings: {
        text: '(ìŠ¬ìŠ¬ ë²„ë¸” íƒ€ì•¼ í•¨)',
        left: '(ì™¼ìª½ DPSê°€ ë²„ë¸” íƒ€ì•¼ í•¨)',
        right: '(ì˜¤ë¥¸ìª½ DPSê°€ ë²„ë¸” íƒ€ì•¼ í•¨)',
      },
    },
    {
      id: 'AAIS Ketuduke Fluke Typhoon Tower',
      type: 'Ability',
      netRegex: { id: '8AB0', source: 'Ketuduke', capture: false },
      suppressSeconds: 5,
      alertText: (_data, _matches, output) => output.text!(),
      outputStrings: {
        text: {
          en: 'ì¥íŒ í”¼í•˜ë©´ì„œ íƒ€ì›Œ ë°Ÿì•„ìš”',
        },
      },
    },
    // ---------------- second trash ----------------
    {
      id: 'AAIS Wood Golem Ancient Aero III',
      type: 'StartsUsing',
      netRegex: { id: '8C4C', source: 'Aloalo Wood Golem' },
      response: Responses.interruptIfPossible(),
    },
    {
      id: 'AAIS Wood Golem Tornado',
      type: 'StartsUsing',
      netRegex: { id: '8BD3', source: 'Aloalo Wood Golem' },
      infoText: (data, matches, output) => {
        if (data.me === matches.target)
          return output.itsme!();
        return output.text!({ player: data.party.member(matches.target).ajob });
      },
      outputStrings: {
        itsme: 'ë‚´ê²Œ í† ë„¤ì´ë„',
        text: 'í† ë„¤ì´ë„: ${player}',
      },
    },
    {
      id: 'AAIS Wood Golem Tornado Esuna',
      type: 'Ability',
      netRegex: { id: '8BD3', source: 'Aloalo Wood Golem' },
      condition: (data) => data.role === 'healer' || data.job === 'BRD',
      alertText: (data, matches, output) =>
        output.text!({ player: data.party.member(matches.target).ajob }),
      outputStrings: {
        text: 'ì—ìŠ¤ë‚˜: ${player}',
      },
    },
    {
      id: 'AAIS Wood Golem Ovation',
      type: 'StartsUsing',
      netRegex: { id: '8BD4', source: 'Aloalo Wood Golem', capture: false },
      infoText: (_data, _matches, output) => output.text!(),
      outputStrings: {
        text: 'ì˜†ì´ë‚˜ ë’¤ë¡œ',
      },
    },
    {
      id: 'AAIS Islekeeper Ancient Quaga',
      type: 'StartsUsing',
      netRegex: { id: '8C39', source: 'Aloalo Islekeeper', capture: false },
      response: Responses.bleedAoe(),
    },
    {
      id: 'AAIS Islekeeper Gravity Force',
      type: 'StartsUsing',
      netRegex: { id: '8C3A', source: 'Aloalo Islekeeper' },
      infoText: (data, matches, output) => {
        if (data.me === matches.target)
          return output.itsme!();
        return output.text!({ player: data.party.member(matches.target).ajob });
      },
      outputStrings: {
        itsme: 'ë‚´ê²Œ ì¤‘ë ¥, ëª¨ì—¬ìˆë‹¤ê°€',
        text: 'ì¤‘ë ¥, ëª¨ì—¬ìˆë‹¤ê°€ (${player})',
      },
    },
    {
      id: 'AAIS Islekeeper Isle Drop',
      type: 'StartsUsing',
      netRegex: { id: '8C3C', source: 'Aloalo Islekeeper', capture: false },
      response: Responses.moveAway('alert'),
    },
    // ---------------- lala ----------------
    {
      id: 'AAIS Lala Inferno Theorem',
      type: 'StartsUsing',
      netRegex: { id: '8C05', source: 'Lala', capture: false },
      response: Responses.aoe(),
    },
    {
      id: 'AAIS Lala Lala íšŒì „',
      type: 'HeadMarker',
      netRegex: { id: ['01E4', '01E5'], target: 'Lala' },
      run: (data, matches) => data.lalaRotate = matches.id === '01E4' ? 'cw' : 'ccw',
    },
    {
      id: 'AAIS Lala Lala 3ê³¼5',
      type: 'GainsEffect',
      // F62 = Times Three
      // F63 = Times Five
      netRegex: { effectId: ['F62', 'F63'], source: 'Lala', target: 'Lala' },
      run: (data, matches) => data.lalaCount = matches.effectId === 'F62' ? 3 : 5,
    },
    {
      id: 'AAIS Lala Player íšŒì „',
      type: 'HeadMarker',
      netRegex: { id: ['01ED', '01EE'] },
      condition: Conditions.targetIsYou(),
      run: (data, matches) => data.lalaMyRotate = matches.id === '01ED' ? 'cw' : 'ccw',
    },
    {
      id: 'AAIS Lala Player 3ê³¼5',
      type: 'GainsEffect',
      // E89 = Times Three
      // ECE = Times Five
      netRegex: { effectId: ['E89', 'ECE'], source: 'Lala' },
      condition: Conditions.targetIsYou(),
      run: (data, matches) => data.lalaMyCount = matches.effectId === 'E89' ? 3 : 5,
    },
    {
      id: 'AAIS LaLa Arcane Blight ë°©í–¥',
      type: 'StartsUsing',
      netRegex: { id: ['8BE2', '8BE3', '8BE4', '8BE5]'], source: 'Lala' },
      run: (data, matches) => {
        const blightMap: { [count: string]: MarchDirection } = {
          '8BE2': 'back',
          '8BE3': 'front',
          '8BE4': 'right',
          '8BE5': 'left',
        } as const;
        data.lalaBlight = blightMap[matches.id.toUpperCase()] ?? 'unknown';
      },
    },
    {
      id: 'AAIS Lala Arcane Blight',
      type: 'StartsUsing',
      netRegex: { id: '8BE6', source: 'Lala', capture: false },
      delaySeconds: 1,
      alertText: (data, _matches, output) => {
        if (data.lalaBlight === 'unknown')
          return output.text!();
        if (data.lalaRotate === 'unknown')
          return output[data.lalaBlight]!();
        if (isReverseRotate(data.lalaRotate, data.lalaCount)) {
          return {
            'front': output.left!(),
            'back': output.right!(),
            'left': output.back!(),
            'right': output.front!(),
            'unknown': output.text!(),
          }[data.lalaBlight];
        }
        return {
          'front': output.right!(),
          'back': output.left!(),
          'left': output.front!(),
          'right': output.back!(),
          'unknown': output.text!(),
        }[data.lalaBlight];
      },
      outputStrings: {
        text: 'ë¹ˆ ê³³ìœ¼ë¡œ~',
        front: Outputs.goFront,
        back: Outputs.getBehind,
        left: Outputs.left,
        right: Outputs.right,
      },
    },
    {
      id: 'AAIS Lala Analysis Unseen',
      type: 'GainsEffect',
      netRegex: { effectId: ['E8E', 'E8F', 'E90', 'E91'], source: 'Lala' },
      condition: Conditions.targetIsYou(),
      run: (data, matches) => {
        const unseenMap: { [count: string]: MarchDirection } = {
          'E8E': 'front',
          'E8F': 'back',
          'E90': 'right',
          'E91': 'left',
        } as const;
        data.lalaMyMarch = unseenMap[matches.effectId] ?? 'unknown';
      },
    },
    {
      id: 'AAIS Lala Arcane Array',
      type: 'Ability',
      netRegex: { id: '8BE7', source: 'Lala', capture: false },
      durationSeconds: 15,
      infoText: (data, _matches, output) => {
        const unseen = output[data.lalaMyMarch]!();
        return output.orbs!({ unseen: unseen });
      },
      outputStrings: {
        orbs: 'ëš¤ë¦° ê³³: ${unseen}',
        front: 'ì•',
        back: 'ë’¤',
        left: 'ì™¼ìª½',
        right: 'ì˜¤ë¥¸ìª½',
        unknown: Outputs.unknown,
      },
    },
    {
      id: 'AAIS Lala Targeted Light!',
      type: 'StartsUsing',
      netRegex: { id: '8CE1', source: 'Lala' },
      condition: Conditions.targetIsYou(),
      alertText: (data, _matches, output) => {
        if (data.lalaMyMarch === 'unknown')
          return output.text!();
        if (data.lalaMyRotate === 'unknown')
          return output[data.lalaMyMarch]!();
        if (isReverseRotate(data.lalaMyRotate, data.lalaMyCount))
          return {
            'front': output.left!(),
            'back': output.right!(),
            'left': output.back!(),
            'right': output.front!(),
          }[data.lalaMyMarch];
        return {
          'front': output.right!(),
          'back': output.left!(),
          'left': output.front!(),
          'right': output.back!(),
        }[data.lalaMyMarch];
      },
      outputStrings: {
        front: 'ë³´ìŠ¤ ë´ìš”',
        back: 'ë’¤ëŒì•„ ë´ìš”',
        left: 'ì˜¤ë¥¸ìª½ ë´ìš”',
        right: 'ì™¼ìª½ ë´ìš”',
        text: 'ì—´ë¦° ê³³ì„ ë³´ìŠ¤ë¡œ',
      },
    },
    {
      id: 'AAIS Lala Strategic Strike',
      type: 'StartsUsing',
      netRegex: { id: '8C04', source: 'Lala' },
      response: Responses.tankBuster(),
    },
    {
      id: 'AAIS Lala Subtractive Suppressor Alpha',
      type: 'GainsEffect',
      netRegex: { effectId: 'E8C', source: 'Lala' },
      run: (data, matches) => {
        if (data.me === matches.target)
          data.lalaSubtractive = parseInt(matches.count);
        data.gainList.push(matches);
      },
    },
    {
      id: 'AAIS Lala Subtractive Suppressor Beta',
      type: 'GainsEffect',
      netRegex: { effectId: 'E8D', source: 'Lala' },
      condition: Conditions.targetIsYou(),
      run: (data, matches) => data.lalaSubtractive = parseInt(matches.count),
    },
    {
      id: 'AAIS Lala Surge Vector',
      type: 'GainsEffect',
      netRegex: { effectId: 'E8B', source: 'Lala' },
      run: (data, matches) => data.gainList.push(matches),
    },
    {
      id: 'AAIS Lala Planar Tactics',
      type: 'Ability',
      netRegex: { id: '8BEF', source: 'Lala', capture: false },
      delaySeconds: 1.2,
      durationSeconds: 10,
      infoText: (data, _matches, output) => {
        if (data.lalaSubtractive === undefined)
          return;

        const list = data.gainList;
        const [s1, s2] = list.filter((x) => x.effectId === 'E8B').map((x) => x.target);
        let issame;
        if (s1 === undefined || s2 === undefined)
          issame = false;
        else {
          const dps1 = data.party.isDPS(s1);
          const dps2 = data.party.isDPS(s2);
          issame = (dps1 && dps2) || (!dps1 && !dps2);
        }

        const mysub = data.lalaSubtractive;
        if (mysub === 1) {
          if (issame)
            return output.no1in!();
          const [pair] = list.filter((x) => parseInt(x.count) === 3);
          const name = pair === undefined ? output.unknown!() : data.party.member(pair.target).ajob;
          return output.no1out!({ name: name });
        }
        if (mysub === 2) {
          if (issame)
            return output.no2out!();
          const [pair] = list.filter((x) => parseInt(x.count) === 2 && x.target !== data.me);
          const name = pair === undefined ? output.unknown!() : data.party.member(pair.target).ajob;
          return output.no2in!({ name: name });
        }
        if (mysub === 3) {
          if (issame)
            return output.no3right!();
          const [pair] = list.filter((x) => parseInt(x.count) === 1);
          const name = pair === undefined ? output.unknown!() : data.party.member(pair.target).ajob;
          return output.no3left!({ name: name });
        }
      },
      run: (data) => data.gainList = [],
      outputStrings: {
        no1out: '[1/ë°”ê¹¥] 3ë²ˆê³¼ í˜ì–´: ${name}',
        no1in: '[1/ì•ˆìª½] 2ë²ˆê³¼ í˜ì–´',
        no2out: '[2/ë°”ê¹¥] 1,3ë²ˆê³¼ í˜ì–´',
        no2in: '[2/ì•ˆìª½] 2ë²ˆê³¼ í˜ì–´: ${name}',
        no3left: '[3/ì•„ë˜ì¤„ ì™¼ìª½] 1ë²ˆê³¼ í˜ì–´: ${name}',
        no3right: '[3/ì•„ë˜ì¤„ ì˜¤ë¥¸ìª½] 2ë²ˆê³¼ í˜ì–´',
        unknown: Outputs.unknown,
      },
    },
    {
      id: 'AAIS Lala March',
      type: 'GainsEffect',
      netRegex: { effectId: ['E83', 'E84', 'E85', 'E86'], source: 'Lala' },
      condition: Conditions.targetIsYou(),
      delaySeconds: (_data, matches) => parseFloat(matches.duration) - 7,
      durationSeconds: 7,
      alertText: (data, matches, output) => {
        const map = {
          'E83': 'front',
          'E84': 'back',
          'E85': 'left',
          'E86': 'right',
        }[matches.effectId];
        if (map === undefined)
          return;
        if (data.lalaMyRotate === 'unknown')
          return output[map]!();
        if (isReverseRotate(data.lalaMyRotate, data.lalaMyCount)) {
          return {
            'front': output.left!(),
            'back': output.right!(),
            'left': output.back!(),
            'right': output.front!(),
          }[map];
        }
        return {
          'front': output.right!(),
          'back': output.left!(),
          'left': output.front!(),
          'right': output.back!(),
        }[map];
      },
      outputStrings: {
        text: 'ê°•ì œì´ë™',
        front: 'ê°•ì œì´ë™: ì•ìœ¼ë¡œ',
        back: 'ê°•ì œì´ë™: ë’¤ë¡œ',
        left: 'ê°•ì œì´ë™: ì™¼ìª½',
        right: 'ê°•ì œì´ë™: ì˜¤ë¥¸ìª½',
      },
    },
    {
      id: 'AAIS Lala Spatial Tactics',
      type: 'Ability',
      netRegex: { id: '8BF7', source: 'Lala', capture: false },
      delaySeconds: 1.2,
      durationSeconds: 20,
      infoText: (data, _matches, output) => {
        if (data.lalaSubtractive === undefined)
          return;
        return output[`no${data.lalaSubtractive}`]!();
      },
      outputStrings: {
        no1: '[1] êµ¬ìŠ¬ ìª½ => ë‹¤ í”¼í•´ìš§',
        no2: '[2] êµ¬ìŠ¬ ìª½ => í•œë²ˆ ë§ì•„ìš”',
        no3: '[3] êµ¬ìŠ¬ ì—†ëŠ”ìª½ => ë‘ë²ˆ ë§ì•„ìš”',
        no4: '[4] êµ¬ìŠ¬ ì—†ëŠ”ìª½ => ì„¸ë²ˆ ë§ì•„ìš”',
      },
    },
    {
      id: 'AAIS Lala Symmetric Surge Partner',
      type: 'Ability',
      netRegex: { id: '8BF8', source: 'Lala', capture: false },
      delaySeconds: 1.2,
      alertText: (data, _matches, output) => {
        const [s1, s2] = data.gainList.filter((x) => x.effectId === 'E8B').map((x) => x.target);
        if (s1 === undefined || s2 === undefined)
          return;

        const dps1 = data.party.isDPS(s1);
        const dps2 = data.party.isDPS(s2);
        const same = (dps1 && dps2) || (!dps1 && !dps2);
        if (same)
          return;

        if (data.role === 'dps')
          return output.swap!();
      },
      outputStrings: {
        swap: 'DPS ìë¦¬ ë°”ê¿”ìš”!',
      },
    },
    {
      id: 'AAIS Lala Symmetric Surge',
      type: 'Ability',
      netRegex: { id: '8BF8', source: 'Lala', capture: false },
      delaySeconds: 31,
      durationSeconds: 5,
      response: Responses.pairStack(),
      run: (data) => data.gainList = [],
    },
    {
      id: 'AAIS Lala Arcane Plot',
      type: 'StartsUsing',
      netRegex: { id: '8BF9', source: 'Lala', capture: false },
      infoText: (_data, _matches, output) => output.text!(),
      outputStrings: {
        text: 'ë°”ê¹¥ìª½ ì«„ ìˆëŠ” ê³³ì´ ë¶ìª½!',
      },
    },
    {
      id: 'AAIS Lala Arcane Plot Spread',
      type: 'GainsEffect',
      netRegex: { effectId: 'B7D', source: 'Lala' },
      condition: (data, matches) =>
        data.me === matches.target && parseFloat(matches.duration) > 1.5,
      response: Responses.spread('alert'),
    },
    // ---------------- statice ----------------
    {
      id: 'AAIS Statice Aero IV',
      type: 'StartsUsing',
      netRegex: { id: '8966', source: 'Statice', capture: false },
      response: Responses.aoe('alert'),
    },
    {
      id: 'AAIS Statice Trick Reload',
      type: 'StartsUsing',
      netRegex: { id: '8967', source: 'Statice', capture: false },
      run: (data) => {
        data.stcReloadCount = 0;
        data.stcReloadFailed = 0;
      },
    },
    {
      id: 'AAIS Statice Locked and Loaded',
      type: 'Ability',
      netRegex: { id: '8925', source: 'Statice', capture: false },
      preRun: (data) => {
        if (data.stcReloadCount === 0)
          data.isStackFirst = false;
        data.stcReloadCount++;
      },
      infoText: (data, _matches, output) => {
        if (data.stcReloadCount === 1)
          return output.spread!();
      },
      outputStrings: {
        spread: '(ë¨¼ì € í©ì–´ì ¸ìš”)',
      },
    },
    {
      id: 'AAIS Statice Misload',
      type: 'Ability',
      netRegex: { id: '8926', source: 'Statice', capture: false },
      preRun: (data) => {
        if (data.stcReloadCount === 0)
          data.isStackFirst = true;
        if (data.stcReloadCount < 7)
          data.stcReloadFailed = data.stcReloadCount;
        data.stcReloadCount++;
      },
      infoText: (data, _matches, output) => {
        if (data.stcReloadCount === 1)
          return output.stacks!();
        if (data.stcReloadCount < 8) {
          const mark = diceToMarker(data.stcReloadFailed);
          return output.text!({ safe: data.stcReloadFailed, mark: mark });
        }
      },
      outputStrings: {
        text: '(ì•ˆì „: ${safe}ë²ˆ${mark})',
        stacks: '(ë¨¼ì € ë­‰ì³ìš”)',
      },
    },
    {
      id: 'AAIS Statice Trapshooting 1',
      type: 'StartsUsing',
      netRegex: { id: '8D1C', source: 'Statice', capture: false },
      alertText: (data, _matches, output) => {
        const prev = data.isStackFirst;
        data.isStackFirst = !data.isStackFirst;
        if (prev)
          return output.stack!();
        return output.spread!();
      },
      outputStrings: {
        stack: Outputs.getTogether,
        spread: Outputs.spread,
      },
    },
    {
      id: 'AAIS Statice Trapshooting 2',
      type: 'StartsUsing',
      netRegex: { id: '8976', source: 'Statice', capture: false },
      alertText: (data, _matches, output) => {
        let ret;
        if (data.stcMyDuration < 10)
          ret = data.isStackFirst ? output.stack!() : output.spread!();
        else if (data.stcMyDuration < 20)
          ret = forceMove(output, data.stcMyMarch, data.isStackFirst);
        else if (data.stcMyDuration > 50)
          ret = forceMove(output, data.stcMyMarch, data.isStackFirst);
        else
          ret = data.isStackFirst ? output.stack!() : output.spread!();
        data.isStackFirst = !data.isStackFirst;
        return ret;
      },
      run: (data) => data.stcMyDuration = 0,
      outputStrings: {
        ...ForceMoveStrings,
      },
    },
    {
      id: 'AAIS Statice Trigger Happy',
      type: 'StartsUsing',
      netRegex: { id: '8968', source: 'Statice', capture: false },
      infoText: (data, _matches, output) => {
        const mark = diceToMarker(data.stcReloadFailed);
        return output.text!({ safe: data.stcReloadFailed, mark: mark });
      },
      outputStrings: {
        text: 'ì•ˆì „: ${safe}ë²ˆ${mark}',
      },
    },
    {
      id: 'AAIS Statice Ring a Ring o\' Explosions',
      type: 'StartsUsing',
      netRegex: { id: '8979', source: 'Statice', capture: false },
      durationSeconds: 8,
      response: (data, _matches, output) => {
        // cactbot-builtin-response
        output.responseOutputStrings = {
          first: {
            en: 'í­íƒ„ í”¼í•´ìš”!',
          },
          second: {
            en: 'í­íƒ„ ìœ„ì¹˜ ê¸°ì–µ! ë¹™ê¸€ë¹™ê¸€!',
          },
          third: {
            en: 'í­íƒ„ì—†ëŠ” ì•ˆì „í•œ ê³³ ì°¾ì•„ìš”!',
          },
          fourth: {
            en: '${safe}ë²ˆ${mark} ìª½ ì•ˆì „í•œ ê³³ìœ¼ë¡œ! ë„ë„› ì¡°ì‹¬!',
          },
          forthMove: {
            en: '${safe}ë²ˆ${mark}',
          },
          ...ForceMoveStrings,
        };
        data.stcRingRing++;
        if (data.stcRingRing === 1)
          return { infoText: output.first!() };
        if (data.stcRingRing === 2)
          return { infoText: output.second!() };
        if (data.stcRingRing === 3)
          return { infoText: output.third!() };
        if (data.stcRingRing === 4) {
          const mark = diceToMarker(data.stcReloadFailed);
          const fourth = output.fourth!({ safe: data.stcReloadFailed, mark: mark });
          if (data.stcMyDuration > 39 && data.stcMyDuration < 50) {
            const aim = output.forthMove!({ safe: data.stcReloadFailed, mark: mark });
            const move = forceMove(output, data.stcMyMarch, undefined, aim);
            return { infoText: fourth, alertText: move };
          }
          return { infoText: fourth };
        }
      },
    },
    {
      id: 'AAIS Statice Dartboard of Dancing Explosives',
      type: 'Ability',
      netRegex: { id: '8CC0', source: 'Statice', capture: false },
      infoText: (_data, _matches, output) => output.text!(),
      run: (data) => data.gainList = [],
      outputStrings: {
        text: 'í­íƒ„ í”¼í•´ì„œ ì•ˆì „í•œ ê³³ìœ¼ë¡œ',
      },
    },
    {
      id: 'AAIS Statice Bull\'s-eye Collect',
      type: 'GainsEffect',
      netRegex: { effectId: 'E9E' },
      run: (data, matches) => data.stcBullsEyes.push(data.party.member(matches.target)),
    },
    {
      id: 'AAIS Statice Bull\'s-eye 1',
      type: 'GainsEffect',
      netRegex: { effectId: 'E9E' },
      condition: (data) => !data.stcSeenPinwheeling,
      delaySeconds: (_data, matches) => parseFloat(matches.duration) - 5,
      suppressSeconds: 1,
      infoText: (data, _matches, output) => {
        if (data.role === 'tank')
          return output.blue!();
        if (data.role === 'healer')
          return output.yellow!();

        const dps = data.stcBullsEyes.filter((x) => x.role === 'dps');
        if (dps.length === 1)
          return output.red!();

        const other = dps[0]?.name !== data.me ? dps[0]?.name : dps[1]?.name;
        if (other === undefined)
          return output.red!();

        const mi = data.party.ajobId(data.me);
        const oi = data.party.ajobId(other);
        if (mi === undefined || oi === undefined || mi < oi)
          return output.red!();

        const roles = data.stcBullsEyes.map((x) => x.role);
        if (roles.includes('healer'))
          return output.blue!();
        return output.yellow!();
      },
      run: (data) => data.stcBullsEyes = [],
      outputStrings: {
        blue: 'ğŸŸ¦íŒŒë‘ ë°Ÿì•„ìš”',
        yellow: 'ğŸŸ¨ë…¸ë‘ ë°Ÿì•„ìš”',
        red: 'ğŸŸ¥ë¹¨ê°• ë°Ÿì•„ìš”',
      },
    },
    {
      id: 'AAIS Statice Beguiling Glitter',
      type: 'Ability',
      netRegex: { id: '8980', source: 'Statice', capture: false },
      condition: (data) => data.stcPop < 2,
      delaySeconds: 3,
      suppressSeconds: 1,
      alertText: (_data, _matches, output) => output.text!(),
      outputStrings: {
        text: {
          en: 'ë„‰ë°±! ì €í•­í•˜ë¼!!!',
        },
      },
    },
    {
      id: 'AAIS Statice Beguiling Glitter In/Out',
      type: 'Ability',
      netRegex: { id: '8980', source: 'Statice', capture: false },
      condition: (data) => data.stcPop < 2,
      delaySeconds: 8.5,
      durationSeconds: 8,
      suppressSeconds: 1,
      infoText: (data, _matches, output) => {
        if (data.isStackFirst)
          return output.out!();
        return output.in!();
      },
      outputStrings: {
        in: 'í•œê°€ìš´ë° => ë°”ê¹¥ì—ì„œ í©ì–´ì ¸ìš”',
        out: 'ë°”ê¹¥ => í•œê°€ìš´ë°ì„œ ë­‰ì³ìš”',
      },
    },
    {
      id: 'AAIS Statice Pop',
      type: 'StartsUsing',
      netRegex: { id: '896B', source: 'Statice', capture: false },
      run: (data) => data.stcPop++,
    },
    {
      id: 'AAIS Statice March',
      type: 'GainsEffect',
      netRegex: { effectId: ['DD2', 'DD3', 'DD4', 'DD5'] },
      condition: Conditions.targetIsYou(),
      run: (data, matches) => {
        const marchMap: { [count: string]: MarchDirection } = {
          'DD2': 'front',
          'DD3': 'back',
          'DD4': 'left',
          'DD5': 'right',
        } as const;
        data.stcMyMarch = marchMap[matches.effectId.toUpperCase()] ?? 'unknown';
        data.stcMyDuration = parseFloat(matches.duration);
      },
    },
    {
      id: 'AAIS Statice Surprising Claw Collect',
      type: 'Tether',
      netRegex: { id: '0011', source: 'Surprising Claw' },
      run: (data, matches) => data.stcClaws.push(matches.target),
    },
    {
      id: 'AAIS Statice Surprising Claw',
      type: 'Tether',
      netRegex: { id: '0011', source: 'Surprising Claw', capture: false },
      delaySeconds: 0.5,
      infoText: (data, _matches, output) => {
        if (!data.stcClaws.includes(data.me))
          return;
        let partner = undefined;
        if (data.stcClaws.length === 2)
          partner = data.stcClaws[0] !== data.me
            ? data.party.member(data.stcClaws[0]).ajob
            : data.party.member(data.stcClaws[1]).ajob;
        if (partner === undefined)
          partner = output.unknown!();
        return output.text!({ partner: partner });
      },
      run: (data) => data.stcClaws = [],
      outputStrings: {
        text: 'ë‚´ê²Œ ë°ìŠ¤ ì†í†±ì´! (${partner})',
        unknown: Outputs.unknown,
      },
    },
    {
      id: 'AAIS Statice Surprising Missile Collect',
      type: 'Tether',
      netRegex: { id: '0011', source: 'Surprising Missile' },
      run: (data, matches) => data.stcMissiles.push(matches.target),
    },
    {
      id: 'AAIS Statice Surprising Missile',
      type: 'Tether',
      netRegex: { id: '0011', source: 'Surprising Missile', capture: false },
      delaySeconds: 0.5,
      infoText: (data, _matches, output) => {
        if (!data.stcMissiles.includes(data.me))
          return;
        let partner = undefined;
        if (data.stcMissiles.length === 2)
          partner = data.stcMissiles[0] !== data.me
            ? data.party.member(data.stcMissiles[0]).ajob
            : data.party.member(data.stcMissiles[1]).ajob;
        if (partner === undefined)
          partner = output.unknown!();
        return output.text!({ partner: partner });
      },
      run: (data) => data.stcMissiles = [],
      outputStrings: {
        text: 'ë¯¸ì‚¬ì¼ + ì²´ì¸, í•œê°€ìš´ë°ë¡œ! (${partner})',
        unknown: Outputs.unknown,
      },
    },
    {
      id: 'AAIS Statice Shocking Abandon',
      type: 'StartsUsing',
      netRegex: { id: '8965', source: 'Statice' },
      response: Responses.tankBuster(),
    },
    {
      id: 'AAIS Statice Pinwheeling Dartboard',
      type: 'Ability',
      netRegex: { id: '8CBF', source: 'Statice', capture: false },
      infoText: (_data, _matches, output) => output.text!(),
      run: (data) => data.stcSeenPinwheeling = true,
      outputStrings: {
        text: 'ê¼­ì§€ì  ì°¾ê³  => í•œê°€ìš´ë°ë¡œ',
      },
    },
    {
      id: 'AAIS Statice Ball of Fire',
      type: 'AddedCombatant',
      netRegex: { npcNameId: '12511' }, // ë™ê¸€
      infoText: (data, matches, output) => {
        data.stcBallFire = stcBallOfFire(matches);
        if (data.stcBallFire > 1000)
          return output.text!({ mesg: `${data.stcBallFire}/${matches.heading}` });
      },
      outputStrings: {
        text: 'í›„: ${mesg}',
      },
    },
    {
      id: 'AAIS Statice Bull\'s-eye 2',
      type: 'GainsEffect',
      netRegex: { effectId: 'E9E', capture: false },
      condition: (data) => data.stcSeenPinwheeling,
      delaySeconds: 1,
      suppressSeconds: 1,
      run: (data) => {
        const roles = data.stcBullsEyes.map((x) => x.role);
        data.stcBullsEyes = [];
        const dps = roles.filter((x) => x === 'dps');
        if (dps.length === 2) {
          data.stcAdjustBullsEye = true;
          return;
        }
        const th = roles.filter((x) => x === 'tank' || x === 'healer');
        if (th.length === 2) {
          data.stcAdjustBullsEye = true;
          return;
        }
        data.stcAdjustBullsEye = false;
      },
    },
    {
      id: 'AAIS Statice Burning Chains Collect',
      type: 'HeadMarker',
      netRegex: { id: '0061' },
      run: (data, matches) => data.stcChains.push(matches.target),
    },
    {
      id: 'AAIS Statice Burning Chains Alert',
      type: 'HeadMarker',
      netRegex: { id: '0061' },
      condition: Conditions.targetIsYou(),
      delaySeconds: 0.1,
      alertText: (data, _matches, output) => {
        if (data.stcChains.length !== 2)
          return output.chain!();
        const partner = data.stcChains[0] !== data.me ? data.stcChains[0] : data.stcChains[1];
        return output.chainWith!({ partner: data.party.member(partner).ajob });
      },
      outputStrings: {
        chain: 'ë‚´ê²Œ ì²´ì¸!',
        chainWith: 'ë‚´ê²Œ ì²´ì¸! (${partner})',
      },
    },
    {
      id: 'AAIS Statice Burning Chains Tether',
      type: 'Tether',
      netRegex: { id: '0009' },
      response: (data, matches, output) => {
        // cactbot-builtin-response
        output.responseOutputStrings = {
          cutchain: {
            en: 'ì²´ì¸ ëŠì–´ìš”!',
          },
          deathclaw: {
            en: 'ë°ìŠ¤ ì†í†± ìœ ë„ => ë­‰ì³ìš”',
          },
          adjustbullseye: {
            en: 'ë¶ìœ¼ë¡œ! ìë¦¬ ì¡°ì • í˜ì–´!',
          },
          bullseye: {
            en: 'ë¶ìœ¼ë¡œ! í˜ì–´',
          },
        };
        if (data.me === matches.source || data.me === matches.target)
          return { alarmText: output.cutchain!() };
        if (data.stcSeenPinwheeling) {
          if (data.stcAdjustBullsEye)
            return { alertText: output.adjustbullseye!() };
          return { infoText: output.bullseye!() };
        }
        return { alertText: output.deathclaw!() }; // ì´ê±´ ë°ìŠ¤ ì†í†± ë°–ì— ì—†ë‹¤
      },
      run: (data) => data.stcChains = [],
    },
    // ---------------------------------------------- í…ŒìŠ¤íŠ¸
    /*
    {
      id: 'AAIS marker test',
      type: 'HeadMarker',
      netRegex: {},
      infoText: (_data, matches, output) => {
        const tested: string[] = [
          '0017', // í©ì–´ì ¸ìš”
          '003E', // ë­‰ì³ìš”
          '0061', // ì²´ì¸
          '00A1', // ë­‰ì³ ëŒ€ìƒì—ê²Œ ì˜´
          '00C6', // ì«„ì´ ì”€. ë”°ë¼ì˜¤ëŠ” ë¨¸ì‹œê¸°
          '00DC', // ì²´ì¸ ëŠê¹€? ì•„ë¬´íŠ¼ Burning Chains ë‹¤ìŒ ë‚˜ì˜´
          '00E5', // í©ì–´ì ¸/ë­‰ì³/ë§¤ì§ì—… ì…‹ì¤‘ í•˜ë‚˜ì¼ê±° ê°™ìŒ...
          '0150', // ì¼€íˆ¬ 1ë²ˆ íœ©ì“¸ë¦¼
          '0151', // ì¼€íˆ¬ 2ë²ˆ
          '01E4', // ë¼ë¼ ë³´ìŠ¤ ì‹œê³„
          '01E5', // ë¼ë¼ ë³´ìŠ¤ ë°˜ì‹œê³„
          '01ED', // ë¼ë¼ í”Œë ˆì´ì–´ ì‹œê³„
          '01EE', // ë¼ë¼ í”Œë ˆì´ì–´ ë°˜ì‹œê³„
          '01F7', // ë¼ë¼ í”Œë ˆì´ì–´ ëª¨ë¥´ê²Ÿë‹¤. ë°©í–¥ ê´€ë ¨ ê°™ì€ë°
          '01F8', // ë¼ë¼ í”Œë ˆì´ì–´ ëª¨ë¥´ê²Ÿë‹¤. ë°©í–¥ ê´€ë ¨ ê°™ì€ë°
          '00F3', // ë¼ë¼ ë²„ìŠ¤í„° Strategic Strike
          '0186', // 186~18B ì£¼ì‚¬ìœ„ ëª¨ì–‘
          '0187',
          '0188',
          '0189',
          '018A',
          '018B',
          '015B', // ìŠ¤íƒ€ í˜ì–´. ê¸°ë¯¹ ì²˜ë¦¬í•˜ë©´ì„œ í•´ê²°ë¨
          '00DA', // ìŠ¤íƒ€ ë²„ìŠ¤í„° Socking Abandon
          '009C', // ìŠ¤íƒ€ Ball of Fire. ë¬¸ì œì˜ ì´ê±° ì–´ë”” ìˆëŠ”ì§€ë§Œ ì•Œë©´...
        ];
        if (tested.includes(matches.id))
          return;
        return output.text!({ id: matches.id, dest: matches.target });
      },
      outputStrings: {
        text: 'í—¤ë“œë§ˆì»¤: ${id} (${dest})',
      },
    },
    */
  ],
  timelineReplace: [
    {
      locale: 'en',
      replaceText: {
        'Hydrobullet/Hydrofall': 'Hydrobullet/fall',
        'Hydrofall/Hydrobullet': 'Hydrofall/bullet',
        'Locked and Loaded/Misload': 'íƒ„ì•Œ ì¥ì „',
        'Receding Twintides/Encroaching Twintides': 'Receding/Encroaching Twintides',
        'Far Tide/Near Tide': 'Far/Near Tide',
      },
    },
    {
      'locale': 'ja',
      'missingTranslations': true,
      'replaceSync': {
        'Aloalo Islekeeper': 'ã‚¢ãƒ­ã‚¢ãƒ­ãƒ»ã‚­ãƒ¼ãƒ‘ãƒ¼',
        'Aloalo Kiwakin': 'ã‚¢ãƒ­ã‚¢ãƒ­ãƒ»ã‚­ãƒ¯ã‚­ãƒ³',
        'Aloalo Monk': 'ã‚¢ãƒ­ã‚¢ãƒ­ãƒ»ãƒ¢ãƒ³ã‚¯',
        'Aloalo Ray': 'ã‚¢ãƒ­ã‚¢ãƒ­ãƒ»ã‚¹ãƒˆãƒ©ã‚¤ãƒ—ãƒ¬ã‚¤',
        'Aloalo Snipper': 'ã‚¢ãƒ­ã‚¢ãƒ­ãƒ»ã‚¹ãƒ‹ãƒƒãƒ‘ãƒ¼',
        'Aloalo Wood Golem': 'ã‚¢ãƒ­ã‚¢ãƒ­ãƒ»ã‚¦ãƒƒãƒ‰ã‚´ãƒ¼ãƒ¬ãƒ ',
        'Ketuduke': 'ã‚±ãƒˆã‚¥ãƒ‰ã‚¥ã‚±',
        'Lala': 'ãƒ©ãƒ©',
        'Spring Crystal': 'æ¹§æ°´ã®ã‚¯ãƒªã‚¹ã‚¿ãƒ«',
        'Statice': 'ã‚¹ã‚¿ãƒ¼ãƒã‚¹',
        'Surprising Claw': 'ã‚µãƒ—ãƒ©ã‚¤ã‚ºãƒ»ã‚¯ãƒ­ãƒ¼',
        'Surprising Missile': 'ã‚µãƒ—ãƒ©ã‚¤ã‚ºãƒ»ãƒŸã‚µã‚¤ãƒ«',
        'The Dawn Trial': 'ãƒ‡ã‚£ãƒ«ãƒ ã®è©¦ç·´',
        'The Dusk Trial': 'ã‚¯ãƒ«ãƒšã®è©¦ç·´',
        'The Midnight Trial': 'ãƒã‚³ã‚»ãƒ­ã®è©¦ç·´',
      },
    },
  ],
};

export default triggerSet;
