// This file was autogenerated from running npm run sync-files.
// DO NOT EDIT THIS FILE DIRECTLY.
// Edit the source file below and then run `npm run sync-files`
// Source: ui/raidboss/data/06-ew/dungeon/another_aloalo_island.ts

import Autumn from '../../../../../resources/autumn';
import Conditions from '../../../../../resources/conditions';
import Outputs from '../../../../../resources/outputs';
import { Responses } from '../../../../../resources/responses';
import ZoneId from '../../../../../resources/zone_id';
import { RaidbossData } from '../../../../../types/data';
import { NetMatches } from '../../../../../types/net_matches';
import { Output, TriggerSet } from '../../../../../types/trigger';

// í”¼ë Œ/í¬ì‹œ: /e prex py,po,pi
// í•˜ë¯€/í¬ì‹œ: /e prex hm,po,pi
// í”¼ë Œ/í•˜ë¯€: /e prex py,hm,pi
// ëª¨ë‘ í•˜ë¯€: /e prex hm,hm,pi

type ClockRotation = 'cw' | 'ccw';
type AloDirection = 'front' | 'back' | 'left' | 'right';

const MarchMoveStrings = {
  stacks: Outputs.getTogether,
  spread: Outputs.spread,
  forward: {
    en: 'Move: Forward => ${dest}', // FIXME
    ja: 'å¼·åˆ¶ç§»å‹• : å‰ => ${dest}',
    ko: 'ê°•ì œì´ë™: ì• ğŸ”œ ${dest}',
  },
  backward: {
    en: 'Move: Back => ${dest}', // FIXME
    ja: 'å¼·åˆ¶ç§»å‹• : å¾Œã‚ => ${dest}',
    ko: 'ê°•ì œì´ë™: ë’¤ ğŸ”œ ${dest}',
  },
  left: {
    en: 'Move: Left => ${dest}', // FIXME
    ja: 'å¼·åˆ¶ç§»å‹• : å·¦ => ${dest}',
    ko: 'ê°•ì œì´ë™: ì™¼ìª½ ğŸ”œ ${dest}',
  },
  right: {
    en: 'Move: Right => ${dest}', // FIXME
    ja: 'å¼·åˆ¶ç§»å‹• : å³ => ${dest}',
    ko: 'ê°•ì œì´ë™: ì˜¤ë¥¸ìª½ ğŸ”œ ${dest}',
  },
} as const;

export interface Data extends RaidbossData {
  readonly triggerSetConfig: {
    stackOrder: 'meleeRolesPartners' | 'rolesPartners';
    flukeGaleType: 'spread' | 'pylene' | 'hamukatsu';
    planarTacticsType: 'count' | 'poshiume' | 'hamukatsu';
    pinwheelingType: 'stack' | 'pino' | 'spell';
  };
  // ketuduke
  ketuCrystalAdd: NetMatches['AddedCombatant'][];
  ketuSpringCrystalCount: number;
  ketuHydroCount: number;
  ketuBuff?: 'bubble' | 'fetters';
  ketuBuffCollect: NetMatches['GainsEffect'][];
  // lala
  lalaRotation?: ClockRotation;
  lalaTimes?: 3 | 5;
  lalaMyRotation?: ClockRotation;
  lalaMyTimes?: 3 | 5;
  lalaUnseen?: AloDirection;
  lalaAlphaGains: NetMatches['GainsEffect'][];
  // statice
  stcReloads: number;
  stcMisload: number;
  stcStackSpread: boolean;
  stcRingRing: number;
  stcBullsEyes: string[];
  stcClaws: string[];
  stcMissiles: string[];
  stcChains: string[];
  stcSeenPinwheeling: boolean;
  stcMarch?: AloDirection;
  stcDuration: number;
  //
  settled: boolean;
}

// Horizontal crystals have a heading of 0, vertical crystals are -pi/2.
const isHorizontalCrystal = (line: NetMatches['AddedCombatant']) => {
  const epsilon = 0.1;
  return Math.abs(parseFloat(line.heading)) < epsilon;
};

// test reverse rotation
const isReverseRotate = (rot: ClockRotation, times: number): boolean => {
  if (rot === 'cw' && times === 3)
    return true;
  if (rot === 'ccw' && times === 5)
    return true;
  return false;
};

//
const marchMove = (
  output: Output,
  march: AloDirection,
  stackFirst: boolean,
  safezone?: string,
): string => {
  const move = {
    'front': output.forward,
    'back': output.backward,
    'left': output.left,
    'right': output.right,
  }[march];
  if (safezone !== undefined)
    return move!({ dest: safezone });
  return move!({ dest: stackFirst ? output.stacks!() : output.spread!() });
};

// ì£¼ì‚¬ìœ„ë¥¼ ë°©í–¥ìœ¼ë¡œ
const diceToArrow = (no: number): string => {
  const arrowMap: { [dice: number]: string } = {
    1: 'ğŸ¡¹',
    2: 'ğŸ¡½',
    3: 'ğŸ¡¾',
    4: 'ğŸ¡»',
    5: 'ğŸ¡¿',
    6: 'ğŸ¡¼',
  } as const;
  const ret = arrowMap[no];
  return ret === undefined ? 'ê”«' : ret;
};

const triggerSet: TriggerSet<Data> = {
  id: 'AnotherAloaloIslandSavage',
  zoneId: ZoneId.AnotherAloaloIslandSavage,
  config: [
    {
      id: 'flukeGaleType',
      name: {
        en: 'Fluke Gale Strat',
        ja: 'Fluke Gale ã‚¿ã‚¤ãƒ—',
        ko: 'Fluke Gale í˜•ì‹',
      },
      type: 'select',
      options: {
        en: {
          'Message only': 'spread',
          'Pylene: Brainless': 'pylene',
          'Hamukasu: North/South static': 'hamukatsu',
        },
        ja: {
          'ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸': 'spread',
          'ã´ã‚Œã‚“: è„³æ­»æ³•': 'pylene',
          'ãƒãƒ ã‚«ãƒ„: å—åŒ—': 'hamukatsu',
        },
        ko: {
          'ë©”ì‹œì§€': 'spread',
          'í”¼ë Œ: ë‡Œì‚¬': 'pylene',
          'í•˜ë¯€ê¹ŒìŠ¤: ë‚¨ë¶ê³ ì •': 'hamukatsu',
        },
      },
      default: 'hamukatsu',
    },
    {
      id: 'planarTacticsType',
      name: {
        en: 'Planar Tactics Strat',
        ja: 'Planar Tactics ã‚¿ã‚¤ãƒ—',
        ko: 'Planar Tactics í˜•ì‹',
      },
      type: 'select',
      options: {
        en: {
          'Count only': 'count',
          'Poshiume: 3 left or right': 'poshiume',
          'Hamukatsu: 3 right only': 'hamukatsu',
        },
        ja: {
          'ã‚«ã‚¦ãƒ³ãƒˆè¡¨ç¤º': 'count',
          'ã½ã—ã†ã‚: 3ç•ªå·¦å³': 'poshiume',
          'ãƒãƒ ã‚«ãƒ„: 3ç•ªå³': 'hamukatsu',
        },
        ko: {
          'ì¹´ìš´íŠ¸ í‘œì‹œ': 'count',
          'í¬ì‹œìš°ë©”: 3ë²ˆ ì¢Œìš° ì‚¬ìš©': 'poshiume',
          'í•˜ë¯€ê¹ŒìŠ¤: 3ë²ˆ í•œìª½ë§Œ ì‚¬ìš©': 'hamukatsu',
        },
      },
      default: 'hamukatsu',
    },
    {
      id: 'pinwheelingType',
      name: {
        en: 'Pinwheeling Strat',
        ja: 'ãƒ€ãƒ¼ãƒˆï¼†ã‚¦ã‚£ãƒ« ã‚¿ã‚¤ãƒ—',
        ko: 'Pinwheeling í˜•ì‹',
      },
      type: 'select',
      options: {
        en: {
          'Message only': 'stack',
          'Pino': 'pino',
          'Spell': 'spell',
        },
        ja: {
          'ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸': 'stack',
          'ã´ã®(ãƒãƒ ã‚«ãƒ„)': 'pino',
          'spell(Game8)': 'spell',
        },
        ko: {
          'ë©”ì‹œì§€': 'stack',
          'í”¼ë…¸': 'pino',
          'ìŠ¤í ': 'spell',
        },
      },
      default: 'pino',
    },
  ],
  timelineFile: 'another_aloalo_island-savage.txt',
  initData: () => {
    return {
      ketuCrystalAdd: [],
      ketuSpringCrystalCount: 0,
      ketuHydroCount: 0,
      ketuBuffCollect: [],
      lalaAlphaGains: [],
      stcReloads: 0,
      stcMisload: 0,
      stcStackSpread: false,
      stcRingRing: 0,
      stcBullsEyes: [],
      stcClaws: [],
      stcMissiles: [],
      stcChains: [],
      stcSeenPinwheeling: false,
      stcDuration: 0,
      settled: false,
    };
  },
  timelineTriggers: [
    {
      id: 'AAIS Options',
      regex: /--setup--/,
      infoText: (data, _matches, output) => {
        if (data.settled)
          return output.settled!();
        data.settled = true;

        if (data.options.AutumnParameter !== undefined) {
          const ss = data.options.AutumnParameter.split(',');
          if (ss.length === 1 && ss[0] === 'hm') {
            data.triggerSetConfig.flukeGaleType = 'hamukatsu';
            data.triggerSetConfig.planarTacticsType = 'hamukatsu';
            data.triggerSetConfig.pinwheelingType = 'pino';
          }
          if (ss.length === 2) {
            data.triggerSetConfig.flukeGaleType = ss[0] === 'hm' ? 'hamukatsu' : 'pylene';
            data.triggerSetConfig.planarTacticsType = ss[1] === 'hm' ? 'hamukatsu' : 'poshiume';
            data.triggerSetConfig.pinwheelingType = 'pino';
          }
          if (ss.length === 3) {
            data.triggerSetConfig.flukeGaleType = ss[0] === 'hm' ? 'hamukatsu' : 'pylene';
            data.triggerSetConfig.planarTacticsType = ss[1] === 'hm' ? 'hamukatsu' : 'poshiume';
            data.triggerSetConfig.pinwheelingType = ss[2] === 'sp' ? 'spell' : 'pino';
          }
        }
        const param = output.options!({
          fluke: {
            'spread': output.spread!(),
            'pylene': output.pylene!(),
            'hamukatsu': output.flukeNs!(),
          }[data.triggerSetConfig.flukeGaleType],
          planar: {
            'count': output.count!(),
            'poshiume': output.planar13!(),
            'hamukatsu': output.planar3!(),
          }[data.triggerSetConfig.planarTacticsType],
          pin: {
            'stack': output.stack!(),
            'pino': output.pino!(),
            'spell': output.spell!(),
          }[data.triggerSetConfig.pinwheelingType],
        });
        return output.mesg!({ param: param });
      },
      outputStrings: {
        settled: {
          en: '(Option already settled)',
          ja: '(è¨­å®šã•ã‚Œã¦ã„ã¾ã™)',
          ko: '(ì„¤ì •ì´ ìˆì–´ìš”)',
        },
        mesg: {
          en: 'Option: ${param}',
          ja: 'ã‚ªãƒ—ã‚·ãƒ§ãƒ³: ${param}',
          ko: 'ì˜µì…˜: ${param}',
        },
        options: {
          en: '${fluke}/${planar}/${pin}',
          ja: '${fluke}/${planar}/${pin}',
          ko: '${fluke}/${planar}/${pin}',
        },
        spread: {
          en: '(spread)',
          ja: '(ãªã—)',
          ko: '(ì—†ìŒ)',
        },
        pylene: {
          en: 'pylene',
          ja: 'ã´ã‚Œã‚“',
          ko: 'í”¼ë Œ',
        },
        flukeNs: {
          en: 'N-S',
          ja: 'å—åŒ—',
          ko: 'ë‚¨ë¶',
        },
        count: {
          en: '(count)',
          ja: '(ã‚«ã‚¦ãƒ³ãƒˆ)',
          ko: '(ì¹´ìš´íŠ¸)',
        },
        planar13: {
          en: '1&3',
          ja: 'ä¸¡æ–¹',
          ko: 'ì–‘ìª½',
        },
        planar3: {
          en: '3',
          ja: 'ç‰‡æ–¹',
          ko: 'í•œìª½',
        },
        stack: {
          en: '(stack)',
          ja: '(ãªã—)',
          ko: '(ì—†ìŒ)',
        },
        pino: {
          en: 'pino',
          ja: 'ã´ã®',
          ko: 'í”¼ë…¸',
        },
        spell: {
          en: 'spell',
          ja: 'spell',
          ko: 'ìŠ¤í ',
        },
      },
    },
  ],
  triggers: [
    // ---------------- first trash ----------------
    {
      id: 'AAIS Kiwakin Lead Hook',
      type: 'StartsUsing',
      netRegex: { id: '8BC7', source: 'Aloalo Kiwakin' },
      response: (data, matches, output) => {
        // cactbot-builtin-response
        output.responseOutputStrings = {
          tankBusterOnYou: {
            en: '3x Tankbuster on YOU',
            de: '3x Tankbuster auf DIR',
            ja: 'è‡ªåˆ†ã«3xã‚¿ãƒ³å¼·',
            ko: 'ë‚´ê²Œ 3ì—°ì† íƒ±í¬ë²„ìŠ¤í„°',
          },
          tankBusterOnPlayer: {
            en: '3x Tankbuster on ${player}',
            de: '3x Tankbuster auf ${player}',
            ja: '3xã‚¿ãƒ³å¼·: ${player}',
            ko: '3ì—°ì† íƒ±í¬ë²„ìŠ¤í„°: ${player}',
          },
        };

        if (matches.target === data.me)
          return { alertText: output.tankBusterOnYou!() };
        const target = data.party.jobAbbr(matches.target);
        return { infoText: output.tankBusterOnPlayer!({ player: target }) };
      },
    },
    {
      id: 'AAIS Kiwakin Sharp Strike',
      type: 'StartsUsing',
      netRegex: { id: '8BC8', source: 'Aloalo Kiwakin' },
      response: Responses.tankBuster(),
    },
    {
      id: 'AAIS Kiwakin Sharp Strike Cleanse',
      type: 'Ability',
      netRegex: { id: '8BC8', source: 'Aloalo Kiwakin' },
      condition: (data) => data.CanCleanse(),
      alertText: (data, matches, output) =>
        output.text!({ player: data.party.jobAbbr(matches.target) }),
      outputStrings: {
        text: {
          en: 'Cleanse ${player}',
          ja: 'ã‚¨ã‚¹ãƒŠ: ${player}',
          ko: 'ì—ìŠ¤ë‚˜: ${player}',
        },
      },
    },
    {
      id: 'AAIS Kiwakin Tail Screw',
      type: 'StartsUsing',
      // This is a baited targeted circle.
      netRegex: { id: '8BC9', source: 'Aloalo Kiwakin', capture: false },
      response: Responses.moveAway(),
    },
    {
      id: 'AAIS Snipper Water III',
      type: 'StartsUsing',
      netRegex: { id: '8BCC', source: 'Aloalo Snipper' },
      response: Responses.stackMarkerOn(),
    },
    {
      id: 'AAIS Snipper Bubble Shower',
      type: 'StartsUsing',
      netRegex: { id: '8BCA', source: 'Aloalo Snipper', capture: false },
      response: Responses.goSides(),
    },
    {
      id: 'AAIS Snipper Crab Dribble',
      type: 'Ability',
      // Crab Dribble 8BCB has a fast cast, so trigger on Bubble Shower ability
      netRegex: { id: '8BCA', source: 'Aloalo Snipper', capture: false },
      suppressSeconds: 5,
      response: Responses.goFront('info'),
    },
    {
      id: 'AAIS Ray Hydrocannon',
      type: 'StartsUsing',
      netRegex: { id: '8C4B', source: 'Aloalo Ray', capture: false },
      response: Responses.getBehind(),
    },
    {
      id: 'AAIS Ray Expulsion',
      type: 'StartsUsing',
      netRegex: { id: '8BCE', source: 'Aloalo Ray', capture: false },
      response: Responses.getOut(),
    },
    {
      id: 'AAIS Ray Electric Whorl',
      type: 'StartsUsing',
      netRegex: { id: '8BCD', source: 'Aloalo Ray', capture: false },
      response: Responses.getUnder('alert'),
    },
    {
      id: 'AAIS Monk Hydroshot',
      type: 'StartsUsing',
      netRegex: { id: '8BCD', source: 'Aloalo Monk' },
      condition: Conditions.targetIsYou(),
      response: Responses.knockbackOn(),
    },
    {
      id: 'AAIS Monk Cross Attack',
      type: 'StartsUsing',
      netRegex: { id: '8C4F', source: 'Aloalo Monk' },
      response: Responses.tankBuster(),
    },
    // ---------------- Ketuduke ----------------
    {
      id: 'AAIS Ketuduke Tidal Roar',
      type: 'StartsUsing',
      netRegex: { id: '8AD4', source: 'Ketuduke', capture: false },
      response: Responses.bleedAoe(),
    },
    {
      id: 'AAIS Ketuduke Spring Crystals',
      type: 'StartsUsing',
      netRegex: { id: '8AA8', source: 'Ketuduke', capture: false },
      run: (data) => {
        data.ketuSpringCrystalCount++;
        data.ketuCrystalAdd = [];
      },
    },
    {
      id: 'AAIS Ketuduke Spring Crystal 1 Collect',
      type: 'AddedCombatant',
      netRegex: { npcNameId: '12606' },
      run: (data, matches) => data.ketuCrystalAdd.push(matches),
    },
    {
      id: 'AAIS Ketuduke Spring Crystal 2 Collect',
      type: 'AddedCombatant',
      netRegex: { npcNameId: '12607' },
      run: (data, matches) => data.ketuCrystalAdd.push(matches),
    },
    {
      id: 'AAIS Ketuduke Bubble Net',
      type: 'StartsUsing',
      netRegex: { id: ['8AC5', '8AAD'], source: 'Ketuduke', capture: false },
      response: Responses.aoe(),
      run: (data) => data.ketuBuffCollect = [],
    },
    {
      id: 'AAIS Ketuduke Bubble Weave/Foamy Fetters',
      type: 'GainsEffect',
      // ECC = Foamy Fetters
      // E9F = Bubble Weave
      netRegex: { effectId: ['ECC', 'E9F'] },
      condition: (data, matches) => {
        data.ketuBuffCollect.push(matches);
        return data.ketuBuffCollect.length === 4;
      },
      durationSeconds: 6,
      alertText: (data, _matches, output) => {
        const myid = data.ketuBuffCollect.find((x) => x.target === data.me)?.effectId;
        if (myid === undefined)
          return;
        data.ketuBuff = myid === 'E9F' ? 'bubble' : 'fetters';

        const partner = data.party.jobAbbr(
          data.ketuBuffCollect.find((x) => x.effectId === myid && x.target !== data.me)?.target,
        ) ?? output.unknown!();
        return output[data.ketuBuff]!({ partner: partner });
      },
      run: (data) => data.ketuBuffCollect,
      outputStrings: {
        bubble: {
          en: 'Bubble (w/ ${partner})',
          ja: 'ãƒãƒ–ãƒ« (${partner})',
          ko: 'ğŸ”µë²„ë¸” (${partner})',
        },
        fetters: {
          en: 'Fetters (w/ ${partner})',
          ja: 'ãƒã‚¤ãƒ³ãƒ‰ (${partner})',
          ko: 'ğŸŸ¡ë°”ì¸ë“œ (${partner})',
        },
        safe: {
          en: 'Safe: ${safe}',
          ja: 'å®‰ç½®: ${safe}',
          ko: 'ì•ˆì „: ${safe}',
        },
        unknown: Outputs.unknown,
      },
    },
    {
      id: 'AAIS Ketuduke Hydro Counter',
      type: 'StartsUsing',
      // 8AB8 = Hydrobullet (spread)
      // 8AB4 = Hydrofall (stack)
      netRegex: { id: ['8AB8', '8AB4'], source: 'Ketuduke', capture: false },
      run: (data) => data.ketuHydroCount++,
    },
    {
      id: 'AAIS Ketuduke Hydrobullet Reminder',
      type: 'GainsEffect',
      netRegex: { effectId: 'EA3' },
      condition: (data) => [2, 4, 5].includes(data.ketuHydroCount),
      delaySeconds: (_data, matches) => parseFloat(matches.duration) - 5,
      durationSeconds: 4,
      suppressSeconds: 5,
      response: Responses.stackPartner('info'),
    },
    {
      id: 'AAIS Ketuduke Hydrofall Reminder',
      type: 'GainsEffect',
      netRegex: { effectId: 'EA4' },
      condition: (data) => [2, 3, 5].includes(data.ketuHydroCount),
      delaySeconds: (_data, matches) => parseFloat(matches.duration) - 5,
      durationSeconds: 4,
      suppressSeconds: 5,
      response: Responses.spread(),
    },
    // Pylene: https://twitter.com/ff14_pylene99/status/1719665676745650610
    // Hamukatu Nanboku: https://ffxiv.link/0102424
    {
      id: 'AAIS Ketuduke Hydro 1', // Fluke Gale
      type: 'StartsUsing',
      netRegex: { id: ['8AB8', '8AB4'], source: 'Ketuduke' },
      condition: (data) => data.ketuHydroCount === 1 || data.ketuHydroCount === 6,
      delaySeconds: 8,
      durationSeconds: 12,
      alertText: (data, matches, output) => {
        const mech = matches.id === '8AB4' ? output.stacks!() : output.spread!();

        if (data.triggerSetConfig.flukeGaleType === 'spread')
          return output.mesg!({ mech: mech });

        if (data.triggerSetConfig.flukeGaleType === 'pylene') {
          if (data.ketuBuff === 'fetters' && matches.id === '8AB8')
            return output.pylene2!({ mech: mech });
          return output.pylene1!({ mech: mech });
        }

        if (data.triggerSetConfig.flukeGaleType === 'hamukatsu') {
          if (data.ketuBuff === 'bubble')
            return output.hamukatsuBubble!({ mech: mech });
          if (matches.id === '8AB4')
            return output.hamukatsu1!({ mech: mech });
          return output.hamukatsu2!({ mech: mech });
        }
      },
      run: (data) => delete data.ketuBuff,
      outputStrings: {
        spread: Outputs.spread,
        stacks: Outputs.stackPartner,
        mesg: {
          en: 'Go to safe tile => ${mech}',
          ja: 'å®‰ç½®ãƒã‚¹ã¸ => ${mech}',
          ko: 'ì•ˆì „ ì¹¸ìœ¼ë¡œ ğŸ”œ ${mech}',
        },
        pylene1: {
          en: 'Go to 1 => ${mech}',
          ja: 'ç¬¬1åŒºåŸŸã¸ => ${mech}',
          ko: 'í”¼ë Œ [1] ğŸ”œ ${mech}',
        },
        pylene2: {
          en: 'Go to 2 => ${mech}',
          ja: 'ç¬¬2åŒºåŸŸã¸ => ${mech}',
          ko: 'í”¼ë Œ [2] ğŸ”œ ${mech}',
        },
        hamukatsu1: {
          en: 'Go to 1 => ${mech}',
          ja: 'ç¬¬1åŒºåŸŸã®å®‰ç½®ãƒã‚¹ã¸ => ${mech}',
          ko: '[1] ì•ˆì „ ì¹¸ ğŸ”œ ${mech}',
        },
        hamukatsu2: {
          en: 'Go to 2 safe tile  => ${mech}',
          ja: 'ç¬¬2åŒºåŸŸã®å®‰ç½®ãƒã‚¹ã¸ => ${mech}',
          ko: '[2] ì•ˆì „ ì¹¸ ğŸ”œ ${mech}',
        },
        hamukatsuBubble: {
          en: 'Go to 2 safe tile (after knockback) => ${mech}',
          ja: 'ç¬¬2åŒºåŸŸã®å®‰ç½®ãƒã‚¹ã¸ => ${mech}',
          ko: '[2] (ë„‰ë°±í›„)ì•ˆì „ ì¹¸ ğŸ”œ ${mech}',
        },
      },
    },
    {
      id: 'AAIS Ketuduke Hydro 2', // Blowing Bubbles / Angry Seas
      type: 'StartsUsing',
      netRegex: { id: ['8AB8', '8AB4'], source: 'Ketuduke' },
      condition: (data) => data.ketuHydroCount === 2 || data.ketuHydroCount === 5,
      durationSeconds: 8,
      alertText: (_data, matches, output) =>
        matches.id === '8AB4' ? output.stacks!() : output.spread!(),
      outputStrings: {
        stacks: Outputs.pairThenSpread,
        spread: Outputs.spreadThenPair,
      },
    },
    {
      id: 'AAIS Ketuduke Receding Twintides',
      type: 'StartsUsing',
      netRegex: { id: '8AE7', source: 'Ketuduke', capture: false },
      alertText: (_data, _matches, output) => output.text!(),
      outputStrings: {
        text: {
          en: 'Out => Stack inside',
          ja: 'å¤– => å†…å´ã§ãƒšã‚¢',
          ko: 'ë°–ì— ìˆë‹¤ ğŸ”œ ì•ˆì—ì„œ í˜ì–´',
        },
      },
    },
    {
      id: 'AAIS Ketuduke Encroaching Twintides',
      type: 'StartsUsing',
      netRegex: { id: '8AE9', source: 'Ketuduke', capture: false },
      alertText: (_data, _matches, output) => output.text!(),
      outputStrings: {
        text: {
          en: 'In => Stack outside',
          ja: 'ãƒœã‚¹ã®ä¸‹ => å¤–å´ã§ãƒšã‚¢',
          ko: 'ì•ˆì— ìˆë‹¤ ğŸ”œ ë°–ì—ì„œ í˜ì–´',
        },
      },
    },
    {
      id: 'AAIS Ketuduke Spring Crystals 2',
      type: 'AddedCombatant',
      netRegex: { npcNameId: '12607', capture: false },
      condition: (data) => data.ketuSpringCrystalCount === 2 && data.ketuCrystalAdd.length === 4,
      delaySeconds: 2,
      durationSeconds: 18,
      infoText: (data, _matches, output) => {
        const horizontal = data.ketuCrystalAdd.filter((x) => isHorizontalCrystal(x));
        const vertical = data.ketuCrystalAdd.filter((x) => !isHorizontalCrystal(x));
        if (horizontal.length !== 2 || vertical.length !== 2)
          return;

        // Crystal positions are always -15, -5, 5, 15.

        // Check if any verticals are on the outer vertical edges.
        for (const line of vertical) {
          const y = parseFloat(line.y);
          if (y < -10 || y > 10) {
            return output.text!({ safe: output.eastWestSafe!() });
          }
        }

        // Check if any horizontals are on the outer horizontal edges.
        for (const line of horizontal) {
          const x = parseFloat(line.x);
          if (x < -10 || x > 10) {
            return output.text!({ safe: output.northSouthSafe!() });
          }
        }

        return output.text!({ safe: output.cornersSafe!() });
      },
      outputStrings: {
        northSouthSafe: {
          en: 'North/South',
          ja: 'å—ãƒ»åŒ—',
          ko: 'â‡…ë‚¨ë¶',
        },
        eastWestSafe: {
          en: 'East/West',
          ja: 'æ±ãƒ»è¥¿',
          ko: 'â‡†ë™ì„œ',
        },
        cornersSafe: {
          en: 'Corners',
          ja: 'éš…ã¸',
          ko: 'âŒêµ¬ì„',
        },
        text: {
          en: 'Safe: ${safe}',
          ja: 'å®‰ç½®: ${safe}',
          ko: 'ì•ˆì „: ${safe}',
        },
      },
    },
    {
      id: 'AAIS Ketuduke Roar Move',
      type: 'StartsUsing',
      netRegex: { id: '8ADC', source: 'Spring Crystal', capture: false },
      condition: (data) => data.ketuHydroCount === 4,
      durationSeconds: 4,
      suppressSeconds: 2,
      alertText: (data, _matches, output) => {
        if (data.ketuBuff === undefined)
          return output.text!();
        return output[data.ketuBuff]!();
      },
      run: (data) => delete data.ketuBuff,
      outputStrings: {
        text: {
          en: 'Behind add',
          ja: 'ã–ã“ã®å¾Œã‚ã«',
          ko: 'ì«„ ë’¤ë¡œ!',
        },
        bubble: {
          en: 'Behind Fetters',
          ja: 'ãƒã‚¤ãƒ³ãƒ‰ã®ã–ã“ã®å¾Œã‚ã«',
          ko: 'ë°”ì¸ë“œğŸŸ¡ ì«„ ë’¤ë¡œ!',
        },
        fetters: {
          en: 'Behind Bubble',
          ja: 'ãƒãƒ–ãƒ«ã®ã–ã“ã®å¾Œã‚ã«',
          ko: 'ë²„ë¸”ğŸ”µ ì«„ ë’¤ë¡œ!',
        },
      },
    },
    {
      id: 'AAIS Ketuduke Angry Seas Knockback',
      type: 'StartsUsing',
      netRegex: { id: '8AE1', source: 'Ketuduke', capture: false },
      response: Responses.knockback(),
    },
    {
      id: 'AAIS Ketuduke Fluke Typhoon Bubble',
      type: 'StartsUsing',
      netRegex: { id: '8AAF', source: 'Ketuduke', capture: false },
      infoText: (data, _matches, output) => {
        if (data.ketuCrystalAdd.length !== 4 || data.ketuCrystalAdd[0] === undefined)
          return output.text!();
        if (data.options.AutumnStyle) {
          if (parseFloat(data.ketuCrystalAdd[0].x) < 0) {
            if (data.role === 'tank' || data.role === 'dps')
              return output.left!();
            return;
          }
          if (data.role === 'healer' || data.role === 'dps')
            return output.right!();
          return;
        }
        if (data.role === 'dps') {
          if (parseFloat(data.ketuCrystalAdd[0].x) < 0)
            return output.left!();
          return output.right!();
        }
      },
      run: (data) => data.ketuCrystalAdd = [],
      outputStrings: {
        text: {
          en: '(Ready to Bubble!)',
          ja: '(ãã‚ãã‚ãƒãƒ–ãƒ«ï¼)',
          ko: '(ìŠ¬ìŠ¬ ë²„ë¸”!)',
        },
        left: {
          en: '(Bubble: Left)',
          ja: '(å·¦ã‹ã‚‰ãƒãƒ–ãƒ«ï¼)',
          ko: '(ì™¼ìª½ì—ì„œ ë²„ë¸”!)',
        },
        right: {
          en: '(Bubble: Right)',
          ja: '(å³ã‹ã‚‰ãƒãƒ–ãƒ«ï¼)',
          ko: '(ì˜¤ë¥¸ìª½ì—ì„œ ë²„ë¸”!)',
        },
      },
    },
    {
      id: 'AAIS Ketuduke Fluke Typhoon Tower',
      type: 'Ability',
      netRegex: { id: '8AB0', source: 'Ketuduke', capture: false },
      suppressSeconds: 5,
      alertText: (_data, _matches, output) => output.text!(),
      outputStrings: {
        text: {
          en: 'Get Tower',
          ja: 'å¡”è¸ã¿',
          ko: 'ì¥íŒ í”¼í•˜ë©´ì„œ íƒ€ì›Œ ë°Ÿì•„ìš”',
        },
      },
    },
    // ---------------- second trash ----------------
    {
      id: 'AAIS Wood Golem Ancient Aero III',
      type: 'StartsUsing',
      netRegex: { id: '8BD2', source: 'Aloalo Wood Golem' },
      condition: (data) => data.CanSilence(),
      response: Responses.interrupt(),
    },
    {
      id: 'AAIS Wood Golem Tornado',
      type: 'StartsUsing',
      netRegex: { id: '8BD3', source: 'Aloalo Wood Golem' },
      response: (data, matches, output) => {
        // cactbot-builtin-response
        output.responseOutputStrings = {
          tornadoOn: {
            en: 'Away from ${player}',
            de: 'Weg von ${player}',
            ja: 'ãƒˆãƒ«ãƒãƒ‰: ${player}',
            ko: 'í† ë„¤ì´ë„: ${player}',
          },
          tornadoOnYou: {
            en: 'Tornado on YOU',
            de: 'Tornado auf DIR',
            ja: 'è‡ªåˆ†ã«ãƒˆãƒ«ãƒãƒ‰',
            ko: 'ë‚´ê²Œ í† ë„¤ì´ë„',
          },
        };

        if (data.me === matches.target)
          return { alertText: output.tornadoOnYou!() };
        return { infoText: output.tornadoOn!({ player: data.party.jobAbbr(matches.target) }) };
      },
    },
    {
      id: 'AAIS Wood Golem Tornado Bind',
      type: 'GainsEffect',
      netRegex: { effectId: 'EC0' },
      condition: (data) => data.CanCleanse(),
      alertText: (data, matches, output) =>
        output.text!({ player: data.party.jobAbbr(matches.target) }),
      outputStrings: {
        text: {
          en: 'Cleanse ${player}',
          de: 'Reinige ${player}',
          ja: 'ã‚¨ã‚¹ãƒŠ: ${player}',
          ko: 'ì—ìŠ¤ë‚˜: ${player}',
        },
      },
    },
    {
      id: 'AAIS Wood Golem Ovation',
      type: 'StartsUsing',
      netRegex: { id: '8BD4', source: 'Aloalo Wood Golem', capture: false },
      response: Responses.getBehind('info'),
    },
    {
      id: 'AAIS Islekeeper Gravity Force',
      type: 'StartsUsing',
      netRegex: { id: '8C3A', source: 'Aloalo Islekeeper' },
      infoText: (data, matches, output) => {
        if (data.me === matches.target)
          return output.itsme!();
        return output.text!({ player: data.party.jobAbbr(matches.target) });
      },
      outputStrings: {
        itsme: {
          en: 'Stack on YOU',
          ja: 'è‡ªåˆ†ã«ã‚°ãƒ©ãƒ“ãƒ‡ãƒ•ã‚©ãƒ¼ã‚¹',
          ko: 'ë‚´ê²Œ ì¤‘ë ¥',
        },
        text: {
          en: 'Stack on ${player}',
          ja: 'ã‚°ãƒ©ãƒ“ãƒ‡ãƒ•ã‚©ãƒ¼ã‚¹: ${player}',
          ko: 'ì¤‘ë ¥: ${player}',
        },
      },
    },
    {
      id: 'AAIS Islekeeper Isle Drop',
      type: 'StartsUsing',
      netRegex: { id: '8C3C', source: 'Aloalo Islekeeper', capture: false },
      response: Responses.moveAway('alert'),
    },
    {
      id: 'AAIS Islekeeper Ancient Quaga',
      type: 'StartsUsing',
      netRegex: { id: '8C39', source: 'Aloalo Islekeeper', capture: false },
      response: Responses.bleedAoe(),
    },
    {
      id: 'AAIS Islekeeper Ancient Quaga Enrage',
      type: 'StartsUsing',
      netRegex: { id: 'TODO', source: 'Aloalo Islekeeper', capture: false },
      alarmText: (_data, _matches, output) => output.text!(),
      outputStrings: {
        text: {
          en: 'Kill Islekeeper!',
          de: 'WÃ¤chter besiegen!',
          ja: 'å€’ã—ã¦ï¼',
          ko: 'ì£½ì—¬ì•¼í•´!',
        },
      },
    },
    // ---------------- lala ----------------
    {
      id: 'AAIS Lala Inferno Theorem',
      type: 'StartsUsing',
      netRegex: { id: '8C05', source: 'Lala', capture: false },
      response: Responses.aoe('alert'),
    },
    {
      id: 'AAIS Lala Rotation Tracker',
      type: 'HeadMarker',
      netRegex: { id: ['01E4', '01E5'], target: 'Lala' },
      run: (data, matches) => data.lalaRotation = matches.id === '01E4' ? 'cw' : 'ccw',
    },
    {
      id: 'AAIS Lala Angular Addition Tracker',
      type: 'GainsEffect',
      netRegex: { effectId: ['F62', 'F63'], source: 'Lala' },
      run: (data, matches) => data.lalaTimes = matches.effectId === 'F62' ? 3 : 5,
    },
    {
      id: 'AAIS LaLa Arcane Blight',
      type: 'StartsUsing',
      netRegex: { id: ['8BE2', '8BE3', '8BE4', '8BE5'], source: 'Lala' },
      delaySeconds: 0.5,
      alertText: (data, matches, output) => {
        const blightMap: { [count: string]: AloDirection } = {
          '8BE2': 'back',
          '8BE3': 'front',
          '8BE4': 'right',
          '8BE5': 'left',
        } as const;
        const blight = blightMap[matches.id.toUpperCase()]!;
        if (data.lalaRotation === undefined || data.lalaTimes === undefined)
          return output[blight]!();
        if (isReverseRotate(data.lalaRotation, data.lalaTimes)) {
          return {
            'front': output.left!(),
            'back': output.right!(),
            'left': output.back!(),
            'right': output.front!(),
          }[blight];
        }
        return {
          'front': output.right!(),
          'back': output.left!(),
          'left': output.front!(),
          'right': output.back!(),
        }[blight];
      },
      run: (data) => {
        delete data.lalaTimes;
        delete data.lalaRotation;
      },
      outputStrings: {
        front: {
          en: 'â’¶ Front',
          ja: 'â’¶ å‰ã¸',
          ko: 'â’¶ ì•ìœ¼ë¡œ',
        },
        back: {
          en: 'â’¸ Behind',
          ja: 'â’¸ èƒŒé¢ã¸',
          ko: 'â’¸ ì—‰ëŒ•ì´ë¡œ',
        },
        left: {
          en: 'â’¹ Left',
          ja: 'â’¹ å·¦ã¸',
          ko: 'â’¹ ì™¼ìª½',
        },
        right: {
          en: 'â’· Right',
          ja: 'â’· å³ã¸',
          ko: 'â’· ì˜¤ë¥¸ìª½',
        },
      },
    },
    {
      id: 'AAIS Lala My Rotation Collect',
      type: 'HeadMarker',
      netRegex: { id: ['01ED', '01EE'] },
      condition: Conditions.targetIsYou(),
      run: (data, matches) => data.lalaMyRotation = matches.id === '01ED' ? 'cw' : 'ccw',
    },
    {
      id: 'AAIS Lala My Times Collect',
      type: 'GainsEffect',
      netRegex: { effectId: ['E89', 'ECE'], source: 'Lala' },
      condition: Conditions.targetIsYou(),
      run: (data, matches) => data.lalaMyTimes = matches.effectId === 'E89' ? 3 : 5,
    },
    {
      id: 'AAIS Lala Unseen',
      type: 'GainsEffect',
      netRegex: { effectId: ['E8E', 'E8F', 'E90', 'E91'], source: 'Lala' },
      condition: Conditions.targetIsYou(),
      durationSeconds: 15,
      infoText: (data, matches, output) => {
        const unseenMap: { [effectId: string]: AloDirection } = {
          E8E: 'front',
          E8F: 'back',
          E90: 'right',
          E91: 'left',
        } as const;
        data.lalaUnseen = unseenMap[matches.effectId];
        const unseen = data.lalaUnseen ?? 'unknown';
        return output.open!({ unseen: output[unseen]!() });
      },
      outputStrings: {
        open: {
          en: 'Open: ${unseen}',
          ja: 'é–‹: ${unseen}',
          ko: 'ëš¤ë¦° ê³³: ${unseen}',
        },
        front: Outputs.front,
        back: Outputs.back,
        left: Outputs.left,
        right: Outputs.right,
        unknown: Outputs.unknown,
      },
    },
    {
      id: 'AAIS Lala Targeted Light',
      type: 'StartsUsing',
      netRegex: { id: '8CE1', source: 'Lala' },
      condition: Conditions.targetIsYou(),
      alertText: (data, _matches, output) => {
        if (data.lalaUnseen === undefined)
          return;
        if (data.lalaMyRotation === undefined || data.lalaMyTimes === undefined)
          return output[data.lalaUnseen]!();
        if (isReverseRotate(data.lalaMyRotation, data.lalaMyTimes))
          return {
            'front': output.left!(),
            'back': output.right!(),
            'left': output.back!(),
            'right': output.front!(),
          }[data.lalaUnseen];
        return {
          'front': output.right!(),
          'back': output.left!(),
          'left': output.front!(),
          'right': output.back!(),
        }[data.lalaUnseen];
      },
      run: (data) => {
        delete data.lalaUnseen;
        delete data.lalaMyTimes;
        delete data.lalaMyRotation;
      },
      outputStrings: {
        front: {
          en: 'Face Towards Lala',
          de: 'Lala anschauen',
          ja: 'ãƒœã‚¹ã‚’è¦‹ã¦',
          ko: 'ë³´ìŠ¤ ë´ìš§',
        },
        back: {
          en: 'Look Away from Lala',
          de: 'Von Lala weg schauen',
          ja: 'å¾Œã‚è¦‹ã¦',
          ko: 'ë’¤ëŒì•„ ë´ìš”',
        },
        left: {
          en: 'Left Flank towards Lala',
          de: 'Linke Seite zu Lala zeigen',
          ja: 'å³è¦‹ã¦',
          ko: 'ì˜¤ë¥¸ìª½ ë´ìš”',
        },
        right: {
          en: 'Right Flank towards Lala',
          de: 'Rechte Seite zu Lala zeigen',
          ja: 'å·¦è¦‹ã¦',
          ko: 'ì™¼ìª½ ë´ìš”',
        },
      },
    },
    {
      id: 'AAIS Lala Strategic Strike',
      type: 'StartsUsing',
      netRegex: { id: '8C04', source: 'Lala' },
      response: Responses.tankBuster(),
    },
    // Poshiume: https://twitter.com/posiumesan/status/1719545249302008122
    // Hamukatsu: https://youtu.be/QqLg3DXxCVA?t=298
    {
      id: 'AAIS Lala Planar Tactics',
      type: 'GainsEffect',
      // E8B Surge Vector
      // E8C Subtractive Suppressor Alpha
      netRegex: { effectId: ['E8B', 'E8C'], source: 'Lala' },
      condition: (data, matches) => {
        data.lalaAlphaGains.push(matches);
        return data.lalaAlphaGains.length === 6;
      },
      durationSeconds: 10,
      suppressSeconds: 999999,
      infoText: (data, _matches, output) => {
        const strat = data.triggerSetConfig.planarTacticsType;
        const stacks = data.lalaAlphaGains.filter((x) => x.effectId === 'E8B').map((x) => x.target);
        const nums = data.lalaAlphaGains.filter((x) => x.effectId === 'E8C');
        const mystr = nums.find((x) => x.target === data.me)?.count;
        if (mystr === undefined)
          return;
        const mycnt = parseInt(mystr);

        if (stacks.length !== 2 || nums.length !== 4 || strat === 'count')
          return output.count!({ num: mycnt });

        if (data.triggerSetConfig.planarTacticsType === 'poshiume') {
          const [s1, s2] = stacks;
          let issame;
          if (s1 === undefined || s2 === undefined)
            issame = false;
          else {
            const dps1 = data.party.isDPS(s1);
            const dps2 = data.party.isDPS(s2);
            issame = (dps1 && dps2) || (!dps1 && !dps2);
          }

          if (mycnt === 1)
            return issame ? output.poshiume1in!() : output.poshiume1out!();
          if (mycnt === 2) {
            if (issame)
              return output.poshiume2out!();
            const pair = nums.find((x) => parseInt(x.count) === 2 && x.target !== data.me);
            const name = pair === undefined ? output.unknown!() : data.party.jobAbbr(pair.target);
            return output.poshiume2in!({ name: name });
          }
          if (mycnt === 3)
            return issame ? output.poshiume3right!() : output.poshiume3left!();
        }

        if (data.triggerSetConfig.planarTacticsType === 'hamukatsu') {
          if (mycnt === 1)
            return output.hamukatsu1!();
          if (mycnt === 3)
            return output.hamukatsu3!();

          const partner = nums.find((x) => x.target !== data.me && parseInt(x.count) === 2);
          if (partner === undefined)
            return output.hamukatsu2!({ partner: output.unknown!() });
          const pname = data.party.jobAbbr(partner.target);

          const [s1, s2] = stacks;
          if (s1 === undefined || s2 === undefined)
            return output.hamukatsu2!({ partner: pname });

          if (stacks.includes(data.me)) {
            const other = s1 === data.me ? s2 : s1;
            const surge = nums.find((x) => x.target === other);
            if (surge === undefined)
              return output.hamukatsu2!({ partner: pname });
            const count = parseInt(surge.count);
            if (count === 1)
              return output.hamukatsu2left!({ partner: pname });
            if (count === 3)
              return output.hamukatsu2right!({ partner: pname });
          } else if (stacks.includes(partner.target)) {
            const other = s1 === partner.target ? s2 : s1;
            const surge = nums.find((x) => x.target === other);
            if (surge === undefined)
              return output.hamukatsu2!({ partner: pname });
            const count = parseInt(surge.count);
            if (count === 1)
              return output.hamukatsu2right!({ partner: pname });
            if (count === 3)
              return output.hamukatsu2left!({ partner: pname });
          }

          const my = data.party.member(data.me);
          const pm = data.party.member(partner.target);
          return Autumn.jobPriority(my.jobIndex) < Autumn.jobPriority(pm.jobIndex)
            ? output.hamukatsu2left!({ partner: pname })
            : output.hamukatsu2right!({ partner: pname });
        }
      },
      run: (data) => data.lalaAlphaGains = [],
      outputStrings: {
        count: {
          en: '${num}',
          ja: 'ã‚«ã‚¦ãƒ³ãƒˆ: ${num}',
          ko: 'ë²ˆí˜¸: ${num}',
        },
        poshiume1out: {
          en: '1 Outside',
          ja: '1å¤–ã€3ã¨ãƒšã‚¢',
          ko: '[1/ë°”ê¹¥] 3ë²ˆê³¼ í˜ì–´',
        },
        poshiume1in: {
          en: '1 Inside',
          ja: '1å†…ã€2ã¨ãƒšã‚¢',
          ko: '[1/ì•ˆìª½] 2ë²ˆê³¼ í˜ì–´',
        },
        poshiume2out: {
          en: '2 Outside',
          ja: '2å¤–ã€1ãƒ»3ã¨ãƒšã‚¢',
          ko: '[2/ë°”ê¹¥] 1,3ë²ˆê³¼ í˜ì–´',
        },
        poshiume2in: {
          en: '2 Inside (w/ ${name})',
          ja: '2å†…ã€2ã¨ãƒšã‚¢ (${name})',
          ko: '[2/ì•ˆìª½] 2ë²ˆê³¼ í˜ì–´ (${name})',
        },
        poshiume3left: {
          en: '3 Left',
          ja: '3å·¦ã‹ã‚‰ã€1ã¨ãƒšã‚¢',
          ko: '[3/ì•„ë˜ì¤„ ì™¼ìª½] 1ë²ˆê³¼ í˜ì–´',
        },
        poshiume3right: {
          en: '3 Right',
          ja: '3å³ã‹ã‚‰ã€2ã¨ãƒšã‚¢',
          ko: '[3/ì•„ë˜ì¤„ ì˜¤ë¥¸ìª½] 2ë²ˆê³¼ í˜ì–´',
        },
        hamukatsu1: {
          en: '1',
          ja: '1ã€2ã¨ãƒšã‚¢',
          ko: '[1] 2ë²ˆê³¼ í˜ì–´',
        },
        hamukatsu2: {
          en: '2 (${partner})',
          ja: '2ã€1ãƒ»3ã¨ãƒšã‚¢ (${partner})',
          ko: '[2] 1,3ë²ˆê³¼ í˜ì–´ (${partner})',
        },
        hamukatsu2left: {
          en: '2 Left (${partner})',
          ja: '2å·¦ã€3ã¨ãƒšã‚¢ (${partner})',
          ko: '[â°â°ğŸ¡¸2] 3ë²ˆê³¼ í˜ì–´ (${partner})',
        },
        hamukatsu2right: {
          en: '2 Right (${partner})',
          ja: '2å³ã€1ã¨ãƒšã‚¢ (${partner})',
          ko: '[2ğŸ¡ºâ±â±] 1ë²ˆê³¼ í˜ì–´ (${partner})',
        },
        hamukatsu3: {
          en: '3',
          ja: '3ã€2ã¨ãƒšã‚¢',
          ko: '[3] 2ë²ˆê³¼ í˜ì–´',
        },
        unknown: Outputs.unknown,
      },
    },
    {
      id: 'AAIS Lala Forward March',
      type: 'GainsEffect',
      // E83 = Forward March
      netRegex: { effectId: 'E83', source: 'Lala' },
      condition: Conditions.targetIsYou(),
      delaySeconds: (_data, matches) => parseFloat(matches.duration) - 7,
      durationSeconds: 7,
      alertText: (data, _matches, output) => {
        if (data.lalaMyRotation === undefined || data.lalaMyTimes === undefined)
          return;
        if (isReverseRotate(data.lalaMyRotation, data.lalaMyTimes))
          return output.left!();
        return output.right!();
      },
      run: (data) => {
        delete data.lalaMyRotation;
        delete data.lalaMyTimes;
      },
      outputStrings: {
        left: {
          en: 'Leftward March',
          de: 'Linker March',
          ja: 'å¼·åˆ¶ç§»å‹• : å·¦',
          ko: 'ê°•ì œì´ë™: ì™¼ìª½',
        },
        right: {
          en: 'Rightward March',
          de: 'Rechter March',
          ja: 'å¼·åˆ¶ç§»å‹• : å³',
          ko: 'ê°•ì œì´ë™: ì˜¤ë¥¸ìª½',
        },
      },
    },
    {
      id: 'AAIS Lala Spatial Tactics',
      type: 'GainsEffect',
      // E8D Subtractive Suppressor Beta
      netRegex: { effectId: 'E8D', source: 'Lala' },
      condition: Conditions.targetIsYou(),
      suppressSeconds: 20,
      infoText: (_data, matches, output) => {
        const num = parseInt(matches.count);
        if (num < 1 || num > 4)
          return;
        return output[`num${num}`]!();
      },
      outputStrings: {
        num1: {
          en: 'One (avoid all)',
          de: 'Eins (alles ausweichen)',
          ja: '[1]',
          ko: '[1] êµ¬ìŠ¬ ìª½ ğŸ”œ ë‹¤ í”¼í•´ìš§',
        },
        num2: {
          en: 'Two (stay middle)',
          de: 'Zwei (steh in der Mitte)',
          ja: '[2]',
          ko: '[2] êµ¬ìŠ¬ ìª½ ğŸ”œ í•œë²ˆ ë§ì•„ìš”',
        },
        num3: {
          en: 'Three (adjacent to middle)',
          de: 'Drei (steh neben der Mitte)',
          ja: '[3]',
          ko: '[3] êµ¬ìŠ¬ ì—†ëŠ”ìª½ ğŸ”œ ë‘ë²ˆ ë§ì•„ìš”',
        },
        num4: {
          en: 'Four',
          de: 'Vier',
          ja: '[4]',
          ko: '[4] êµ¬ìŠ¬ ì—†ëŠ”ìª½ ğŸ”œ ì„¸ë²ˆ ë§ì•„ìš”',
        },
      },
    },
    {
      id: 'AAIS Lala Arcane Plot',
      type: 'StartsUsing',
      netRegex: { id: '8BF9', source: 'Lala', capture: false },
      infoText: (_data, _matches, output) => output.text!(),
      outputStrings: {
        text: {
          en: 'Find outside adds!',
          ja: 'ãƒãƒƒãƒ—ã®å¤–ã«ã‚¦ãƒƒãƒ‰ã‚´ãƒ¼ãƒ¬ãƒ ï¼',
          ko: 'ë°”ê¹¥ ì«„ ìˆëŠ”ë°ê°€ ë¶ìª½!',
        },
      },
    },
    {
      id: 'AAIS Lala Arcane Point',
      type: 'StartsUsing',
      netRegex: { id: '8BFC', source: 'Lala', capture: false },
      infoText: (_data, _matches, output) => output.text!(),
      run: (data) => data.lalaAlphaGains = [], // Surge Vector ë¦¬ì…‹í•  ê³³ì´ ì—¬ê¸°ë¿
      outputStrings: {
        text: {
          en: 'Spread!',
          ja: 'æ•£ä¼šï¼',
          ko: 'ìê¸° ìë¦¬ë¡œ í©ì–´ì ¸ìš”!',
        },
      },
    },
    {
      id: 'AAIS Lala Arcane Point Spread',
      type: 'GainsEffect',
      // B7D Magic Vulnerability Up (ì—¬ê¸°ì„œëŠ” 1.96ì„)
      netRegex: { effectId: 'B7D', source: 'Lala' },
      condition: (data, matches) => {
        if (data.me !== matches.target)
          return;
        return parseFloat(matches.duration) > 1.9;
      },
      response: Responses.spread('alert'),
    },
    {
      id: 'AAIS Lala Arcane Point Stack',
      type: 'GainsEffect',
      // B7D Magic Vulnerability Up (ì—¬ê¸°ì„œëŠ” 1.0ì„)
      netRegex: { effectId: 'B7D', source: 'Lala' },
      condition: (data, matches) => {
        if (data.me !== matches.target)
          return;
        const duration = parseFloat(matches.duration);
        return duration > 0.99 && duration < 1.9;
      },
      response: Responses.stackPartner(),
    },
    // ---------------- statice ----------------
    {
      id: 'AAIS Statice Aero IV',
      type: 'StartsUsing',
      netRegex: { id: '8966', source: 'Statice', capture: false },
      response: Responses.aoe('alert'),
    },
    {
      id: 'AAIS Statice Trick Reload',
      type: 'StartsUsing',
      netRegex: { id: '8967', source: 'Statice', capture: false },
      run: (data) => {
        data.stcReloads = 0;
        data.stcMisload = 0;
      },
    },
    {
      id: 'AAIS Statice Locked and Loaded',
      type: 'Ability',
      netRegex: { id: '8925', source: 'Statice', capture: false },
      preRun: (data) => {
        if (data.stcReloads === 0)
          data.stcStackSpread = false;
        data.stcReloads++;
      },
      infoText: (data, _matches, output) => {
        if (data.stcReloads === 1)
          return output.spread!();
      },
      outputStrings: {
        spread: {
          en: '(Spread, for later)',
          ja: '(å¾Œã§æ•£ä¼š)',
          ko: '(ë¨¼ì € í©ì–´ì ¸ìš”)',
        },
      },
    },
    {
      id: 'AAIS Statice Misload',
      type: 'Ability',
      netRegex: { id: '8926', source: 'Statice', capture: false },
      preRun: (data) => {
        if (data.stcReloads === 0)
          data.stcStackSpread = true;
        if (data.stcReloads < 7)
          data.stcMisload = data.stcReloads;
        data.stcReloads++;
      },
      infoText: (data, _matches, output) => {
        if (data.stcReloads === 1)
          return output.stacks!();
        if (data.stcReloads < 8) {
          const arrow = diceToArrow(data.stcMisload);
          return output.text!({ safe: data.stcMisload, arrow: arrow });
        }
      },
      outputStrings: {
        text: {
          en: '(${safe}${arrow}, for later)',
          ja: '(å®‰ç½®: ${safe}${arrow})',
          ko: '(ì•ˆì „: ${safe}${arrow})',
        },
        stacks: {
          en: '(Stack, for later)',
          ja: '(å¾Œã§é ­å‰²ã‚Š)',
          ko: '(ë¨¼ì € ë­‰ì³ìš”)',
        },
      },
    },
    {
      id: 'AAIS Statice Trapshooting 1',
      type: 'StartsUsing',
      netRegex: { id: '8D1C', source: 'Statice', capture: false },
      alertText: (data, _matches, output) => {
        if (data.stcStackSpread)
          return output.stacks!();
        return output.spread!();
      },
      run: (data) => data.stcStackSpread = !data.stcStackSpread,
      outputStrings: {
        stacks: Outputs.getTogether,
        spread: Outputs.spread,
      },
    },
    {
      id: 'AAIS Statice Trapshooting 2',
      type: 'StartsUsing',
      netRegex: { id: '8976', source: 'Statice', capture: false },
      alertText: (data, _matches, output) => {
        if (data.stcMarch !== undefined) {
          const march = marchMove(output, data.stcMarch, data.stcStackSpread);
          delete data.stcMarch;
          return march;
        }
        return data.stcStackSpread ? output.stacks!() : output.spread!();
      },
      run: (data) => data.stcStackSpread = !data.stcStackSpread,
      outputStrings: {
        ...MarchMoveStrings,
      },
    },
    {
      id: 'AAIS Statice Trigger Happy',
      type: 'StartsUsing',
      netRegex: { id: '8968', source: 'Statice', capture: false },
      infoText: (data, _matches, output) => {
        const arrow = diceToArrow(data.stcMisload);
        return output.text!({ safe: data.stcMisload, arrow: arrow });
      },
      outputStrings: {
        text: {
          en: 'Safe: ${safe}${arrow}',
          ja: 'å®‰ç½®: ${safe}${arrow}',
          ko: 'ì•ˆì „: ${safe}${arrow}',
        },
      },
    },
    {
      id: 'AAIS Statice Ring a Ring o\' Explosions',
      type: 'StartsUsing',
      netRegex: { id: '8979', source: 'Statice', capture: false },
      durationSeconds: 6,
      response: (data, _matches, output) => {
        // cactbot-builtin-response
        output.responseOutputStrings = {
          move1: {
            en: 'Avoid Bomb!',
            ja: 'çˆ†å¼¾å›é¿ï¼',
            ko: 'í­íƒ„ í”¼í•´ìš”!',
          },
          move2: {
            en: 'Remember Bomb position!',
            ja: 'çˆ†å¼¾ã®ä½ç½®ã‚’ãŠã¼ãˆã¦ï¼',
            ko: 'í­íƒ„ ìœ„ì¹˜ ê¸°ì–µ! ë¹™ê¸€ë¹™ê¸€!',
          },
          move3: {
            en: 'Avoid Bomb!',
            ja: 'çˆ†å¼¾å›é¿ï¼',
            ko: 'í­íƒ„ì—†ëŠ” ì•ˆì „í•œ ê³³ ì°¾ì•„ìš”!',
          },
          move4: {
            en: 'Safe: ${mesg}',
            ja: 'å®‰ç½®: ${mesg}',
            ko: 'ì•ˆì „: ${mesg}',
          },
          mesg4: {
            en: '${safe}${arrow}, avoid donuts',
            ja: '${safe}${arrow}ã¸ã€ãƒ‰ãƒ¼ãƒŠãƒ„å›é¿',
            ko: '${safe}${arrow}, ë„ë„› ì¡°ì‹¬!',
          },
          ...MarchMoveStrings,
        };
        data.stcRingRing++;
        if (data.stcRingRing === 1)
          return { infoText: output.move1!() };
        if (data.stcRingRing === 2)
          return { infoText: output.move2!() };
        if (data.stcRingRing === 3)
          return { infoText: output.move3!() };
        if (data.stcRingRing === 4) {
          const arrow = diceToArrow(data.stcMisload);
          const mesg4 = output.mesg4!({ safe: data.stcMisload, arrow: arrow });
          if (data.stcMarch === undefined || data.stcDuration > 40) // 51ì´ˆëŠ” ë‚˜ì¤‘ì— íŠ¸ë©ìŠˆíŒ…2
            return { alertText: output.move4!({ mesg: mesg4 }) };
          const march = marchMove(output, data.stcMarch, false, mesg4);
          delete data.stcMarch;
          return { alertText: march };
        }
      },
    },
    {
      id: 'AAIS Statice Dartboard of Dancing Explosives',
      type: 'Ability',
      netRegex: { id: '8CC0', source: 'Statice', capture: false },
      infoText: (_data, _matches, output) => output.text!(),
      outputStrings: {
        text: {
          en: 'Go to safe zone',
          ja: 'ãƒœãƒ ã‚’å›é¿ã—ã«å®‰ç½®ã¸',
          ko: 'í­íƒ„ í”¼í•´ì„œ ì•ˆì „í•œ ê³³ìœ¼ë¡œ',
        },
      },
    },
    {
      id: 'AAIS Statice Bull\'s-eye Collect',
      type: 'GainsEffect',
      netRegex: { effectId: 'E9E' },
      run: (data, matches) => data.stcBullsEyes.push(matches.target),
    },
    {
      id: 'AAIS Statice Bull\'s-eye 1',
      type: 'GainsEffect',
      netRegex: { effectId: 'E9E' },
      condition: (data) => !data.stcSeenPinwheeling,
      delaySeconds: (_data, matches) => parseFloat(matches.duration) - 5,
      suppressSeconds: 1,
      infoText: (data, _matches, output) => {
        if (data.role === 'tank')
          return output.blue!();
        if (data.role === 'healer')
          return output.yellow!();

        const members = data.party.members(data.stcBullsEyes);
        const dps = members.filter((x) => x.role === 'dps');
        if (dps.length === 1)
          return output.red!();

        const roles = members.map((x) => x.role);
        if (roles.includes('healer'))
          return output.redBlue!();
        return output.redYellow!();
      },
      run: (data) => data.stcBullsEyes = [],
      outputStrings: {
        blue: {
          en: 'Go to Blue',
          ja: 'é’ã¸',
          ko: 'ğŸŸ¦íŒŒë‘ ë°Ÿì•„ìš”',
        },
        yellow: {
          en: 'Go to Yellow',
          ja: 'é»„è‰²ã¸',
          ko: 'ğŸŸ¨ë…¸ë‘ ë°Ÿì•„ìš”',
        },
        red: {
          en: 'Go to Red',
          ja: 'èµ¤ã¸',
          ko: 'ğŸŸ¥ë¹¨ê°• ë°Ÿì•„ìš”',
        },
        redBlue: {
          en: 'Go to Red (or Blue)',
          ja: 'èµ¤ã¸ (ã¾ãŸã¯é’)',
          ko: 'ğŸŸ¥ë¹¨ê°•(ì•„ë‹ˆë©´ ğŸŸ¦íŒŒë‘) ë°Ÿì•„ìš”',
        },
        redYellow: {
          en: 'Go to Red (or Yellow)',
          ja: 'èµ¤ã¸ (ã¾ãŸã¯é»„è‰²)',
          ko: 'ğŸŸ¥ë¹¨ê°•(ì•„ë‹ˆë©´ ğŸŸ¨ë…¸ë‘) ë°Ÿì•„ìš”',
        },
      },
    },
    {
      id: 'AAIS Statice Pop',
      type: 'StartsUsing',
      netRegex: { id: '896B', source: 'Statice', capture: false },
      suppressSeconds: 10,
      alertText: (data, _matches, output) => {
        const safe = data.stcMisload;
        if (safe === 0)
          return output.knockback!();
        const arrow = diceToArrow(data.stcMisload);
        return output.knockbackSafe!({ safe: safe, arrow: arrow });
      },
      outputStrings: {
        knockback: Outputs.knockback,
        knockbackSafe: {
          en: 'Knockback to ${safe}${arrow}',
          ja: 'ã¸ãƒãƒƒã‚¯ãƒãƒƒã‚¯ (${safe}${arrow})',
          ko: 'ë„‰ë°±! (${safe}${arrow})',
        },
      },
    },
    {
      id: 'AAIS Statice Pop Trapshooting',
      type: 'StartsUsing',
      netRegex: { id: '896B', source: 'Statice', capture: false },
      delaySeconds: 3,
      durationSeconds: 8,
      suppressSeconds: 10,
      infoText: (data, _matches, output) => {
        if (data.stcStackSpread)
          return output.out!();
        return output.in!();
      },
      outputStrings: {
        in: {
          en: 'Middle => Spread outside',
          ja: 'çœŸã‚“ä¸­ => å¤–å´ã§æ•£ä¼š',
          ko: 'í•œê°€ìš´ë°ë¡œ (ë°”ê¹¥ìœ¼ë¡œ í©ì–´ì§ˆêº¼ì„)',
        },
        out: {
          en: 'Out => Stack in middle',
          ja: 'å¤– => çœŸã‚“ä¸­ã§é ­å‰²ã‚Š',
          ko: 'ë°”ê¹¥ìœ¼ë¡œ (í•œê°€ìš´ë°ì„œ ë­‰ì¹ êº¼ì„)',
        },
      },
    },
    {
      id: 'AAIS Statice Face',
      type: 'GainsEffect',
      netRegex: { effectId: ['DD2', 'DD3', 'DD4', 'DD5'] },
      condition: Conditions.targetIsYou(),
      run: (data, matches) => {
        const marchMap: { [effectIds: string]: AloDirection } = {
          DD2: 'front',
          DD3: 'back',
          DD4: 'left',
          DD5: 'right',
        } as const;
        data.stcMarch = marchMap[matches.effectId];
        data.stcDuration = parseFloat(matches.duration);
      },
    },
    {
      id: 'AAIS Statice Surprising Claw',
      type: 'Tether',
      netRegex: { id: '0011', source: 'Surprising Claw' },
      condition: (data, matches) => {
        data.stcClaws.push(matches.target);
        return data.stcClaws.length === 2;
      },
      infoText: (data, _matches, output) => {
        if (!data.stcClaws.includes(data.me))
          return;
        const partner = data.stcClaws[data.stcClaws[0] !== data.me ? 0 : 1];
        return output.text!({
          partner: partner !== undefined ? data.party.jobAbbr(partner) : output.unknown!(),
        });
      },
      run: (data) => data.stcClaws = [],
      outputStrings: {
        text: {
          en: 'Death Claw on YOU! (w/ ${partner})',
          ja: 'è‡ªåˆ†ã«ã‚¯ãƒ­ã‚¦ (${partner})',
          ko: 'ë‚´ê²Œ ë°ìŠ¤ ì†í†±ì´! (${partner})',
        },
        unknown: Outputs.unknown,
      },
    },
    {
      id: 'AAIS Statice Surprising Missile',
      type: 'Tether',
      netRegex: { id: '0011', source: 'Surprising Missile' },
      condition: (data, matches) => {
        data.stcMissiles.push(matches.target);
        return data.stcMissiles.length === 2;
      },
      infoText: (data, _matches, output) => {
        if (!data.stcMissiles.includes(data.me))
          return;
        const partner = data.stcMissiles[data.stcMissiles[0] !== data.me ? 0 : 1];
        return output.text!({
          partner: partner !== undefined ? data.party.jobAbbr(partner) : output.unknown!(),
        });
      },
      run: (data) => data.stcMissiles = [],
      outputStrings: {
        text: {
          en: 'Missile + Tether on YOU! (w/ ${partner})',
          ja: 'è‡ªåˆ†ã«ãƒŸã‚µã‚¤ãƒ«+ãƒã‚§ã‚¤ãƒ³ (${partner})',
          ko: 'ë¯¸ì‚¬ì¼ + ì²´ì¸, í•œê°€ìš´ë°ë¡œ! (${partner})',
        },
        unknown: Outputs.unknown,
      },
    },
    {
      id: 'AAIS Statice Shocking Abandon',
      type: 'StartsUsing',
      netRegex: { id: '8965', source: 'Statice' },
      response: Responses.tankBuster(),
    },
    {
      id: 'AAIS Statice Pinwheeling Dartboard',
      type: 'Ability',
      netRegex: { id: '8CBF', source: 'Statice', capture: false },
      alertText: (_data, _matches, output) => output.text!(),
      run: (data) => data.stcSeenPinwheeling = true,
      outputStrings: {
        text: {
          en: 'Find the angular point!',
          ja: 'åŒ—ã‚’ç‰¹å®šã—ã¦ï¼',
          ko: 'ê¼­ì§€ì  ì°¾ì•„ìš”!',
        },
      },
    },
    {
      id: 'AAIS Statice Pinwheeling Dartboard Color',
      type: 'AddedCombatant',
      netRegex: { npcNameId: '12507' },
      infoText: (_data, matches, output) => {
        const centerX = -200;
        const centerY = 0;
        const x = parseFloat(matches.x) - centerX;
        const y = parseFloat(matches.y) - centerY;

        // 12 pie slices, the edge of the first one is directly north.
        // It goes in B R Y order repeating 4 times.
        // The 0.5 subtraction (12 - 0.5 = 11.5) is because the Homing Pattern
        // lands directly in the middle of a slice.
        const dir12 = Math.round(6 - 6 * Math.atan2(x, y) / Math.PI + 11.5) % 12;

        const colorOffset = dir12 % 3;
        const colorMap: { [offset: number]: string } = {
          0: 'blue',
          1: 'red',
          2: 'yellow',
        } as const;
        const color = colorMap[colorOffset];
        if (color !== undefined)
          return output[color]!();
      },
      outputStrings: {
        blue: {
          en: 'Avoid Blue',
          ja: 'ç‰ã¯é’',
          ko: 'ğŸŸ¦íŒŒë‘ì— êµ¬ìŠ¬',
        },
        red: {
          en: 'Avoid Red',
          ja: 'ç‰ã¯èµ¤',
          ko: 'ğŸŸ¥ë¹¨ê°•ì— êµ¬ìŠ¬',
        },
        yellow: {
          en: 'Avoid Yellow',
          ja: 'ç‰ã¯é»„è‰²',
          ko: 'ğŸŸ¨ë…¸ë‘ì— êµ¬ìŠ¬',
        },
      },
    },
    {
      id: 'AAIS Statice Ball of Fire Rotation',
      type: 'HeadMarker',
      netRegex: { id: ['009C', '009D'] },
      durationSeconds: 13,
      infoText: (_data, matches, output) => {
        if (matches.id === '009C')
          return output.clock!();
        return output.counter!();
      },
      outputStrings: {
        clock: {
          en: 'â¤¾Clockwise',
          ja: 'â¤¾æ™‚è¨ˆ',
          ko: 'â¤¾ì‹œê³„ íšŒì „',
        },
        counter: {
          en: 'â¤¿Counter Clockwise',
          ja: 'â¤¿åæ™‚è¨ˆ',
          ko: 'â¤¿ë°˜ì‹œê³„ íšŒì „',
        },
      },
    },
    {
      id: 'AAIS Statice Burning Chains',
      type: 'HeadMarker',
      netRegex: { id: '0061' },
      condition: (data, matches) => {
        data.stcChains.push(matches.target);
        return data.stcChains.length === 2;
      },
      alertText: (data, _matches, output) => {
        if (!data.stcChains.includes(data.me))
          return;
        const partner = data.stcChains[data.stcChains[0] !== data.me ? 0 : 1];
        return output.text!({
          partner: partner !== undefined ? data.party.jobAbbr(partner) : output.unknown!(),
        });
      },
      run: (data) => data.stcChains = [],
      outputStrings: {
        text: {
          en: 'Tether on YOU! (w/ ${partner})',
          ja: 'è‡ªåˆ†ã«ãƒã‚§ã‚¤ãƒ³ (${partner})',
          ko: 'ë‚´ê²Œ ì²´ì¸! (${partner})',
        },
        unknown: Outputs.unknown,
      },
    },
    {
      // Pino: https://twitter.com/pino_mujuuryoku/status/1720127076190306359
      // Spell: https://twitter.com/spell_ff14/status/1720068760068120970
      id: 'AAIS Statice Break Burning Chains',
      type: 'Tether',
      netRegex: { id: '0009' },
      response: (data, matches, output) => {
        // cactbot-builtin-response
        output.responseOutputStrings = {
          cutchain: {
            en: 'Break Tether!',
            ja: 'ãƒã‚§ã‚¤ãƒ³åˆ‡ã‚‹',
            ko: 'ì²´ì¸ ëŠì–´ìš”!',
          },
          deathclaw: {
            en: 'Bait Claw => Stack',
            ja: 'ã‚¯ãƒ­ã‚¦èª˜å° => é ­å‰²ã‚Š',
            ko: 'ë°ìŠ¤ ì†í†± ìœ ë„ ğŸ”œ ë­‰ì³ìš”',
          },
          pinoAdjust: {
            en: 'Pair! (Adjust)',
            ja: 'åŒ—ã¸ï¼ å¸­å…¥ã‚Œæ›¿ãˆ',
            ko: 'ë¶ìœ¼ë¡œ! ìë¦¬ ì¡°ì • í˜ì–´!',
          },
          pinoStacks: {
            en: 'Pair!',
            ja: 'åŒ—ã¸',
            ko: 'ë¶ìœ¼ë¡œ! ì¡°ì •ì—†ì´ í˜ì–´',
          },
          spellStacks: {
            en: 'Pair!',
            ja: 'åŒ—ã¸',
            ko: 'ë¶ìœ¼ë¡œ! í˜ì–´',
          },
          spellLeft: {
            en: 'Pair and left (w/ ${partner})',
            ja: 'åŒ—ã®å·¦ã¸ (${partner})',
            ko: 'ë¶ìœ¼ë¡œ! í˜ì–´ ì™¼ìª½ (${partner})',
          },
          spellRight: {
            en: 'Pair and right (w/ ${partner})',
            ja: 'åŒ—ã®å³ã¸ (${partner})',
            ko: 'ë¶ìœ¼ë¡œ! í˜ì–´ ì˜¤ë¥¸ìª½ (${partner})',
          },
          stacks: Outputs.stackPartner,
          unknown: Outputs.unknown,
        };
        if (data.me === matches.source || data.me === matches.target)
          return { alarmText: output.cutchain!() };
        if (!data.stcSeenPinwheeling)
          return { alertText: output.deathclaw!() };

        if (data.triggerSetConfig.pinwheelingType === 'stack')
          return { infoText: output.stacks!() };

        if (data.triggerSetConfig.pinwheelingType === 'pino') {
          const members = data.party.members(data.stcBullsEyes);
          const roles = members.map((x) => x.role);

          const dps = roles.filter((x) => x === 'dps');
          if (dps.length === 2)
            return { alertText: output.pinoAdjust!() };

          const th = roles.filter((x) => x === 'tank' || x === 'healer');
          if (th.length === 2)
            return { alertText: output.pinoAdjust!() };

          return { infoText: output.pinoStacks!() };
        }

        if (data.triggerSetConfig.pinwheelingType === 'spell') {
          if (data.stcBullsEyes.length !== 2)
            return { infoText: output.spellStacks!() };

          const members = data.party.members(data.stcBullsEyes);
          const other = members[members[0]?.name === data.me ? 1 : 0];
          if (other === undefined)
            return { infoText: output.spellStacks!() };

          const chains = data.stcChains;
          if (chains.includes(other.name)) {
            const partner = data.party.partyNames.find((x) => x !== data.me && !chains.includes(x));
            if (partner === undefined)
              return { alertText: output.spellLeft!({ partner: output.unknown!() }) };
            return { alertText: output.spellLeft!({ partner: data.party.jobAbbr(partner) }) };
          }

          const myprior = Autumn.jobPriority(data.party.jobIndex(data.me));
          const otherprior = Autumn.jobPriority(other.jobIndex);
          return myprior < otherprior
            ? { alertText: output.spellLeft!({ partner: data.party.jobAbbr(other.name) }) }
            : { alertText: output.spellRight!({ partner: data.party.jobAbbr(other.name) }) };
        }
      },
      run: (data) => {
        data.stcChains = [];
        data.stcBullsEyes = [];
      },
    },
  ],
  timelineReplace: [
    {
      'locale': 'en',
      'replaceText': {
        'Far Tide/Near Tide': 'Far/Near Tide',
        'Hydrobullet/Hydrofall': 'Hydrobullet/fall',
        'Hydrofall/Hydrobullet': 'Hydrofall/bullet',
        'Receding Twintides/Encroaching Twintides': 'Receding/Encroaching Twintides',
      },
    },
    {
      'locale': 'de',
      'replaceSync': {
        'Aloalo Golem': 'Aloalo-Holzgolem',
        'Aloalo Islekeeper': 'Aloalo-WÃ¤chter',
        'Aloalo Kiwakin': 'Aloalo-Kiwakin',
        'Aloalo Monk': 'Aloalo-MÃ¶nch',
        'Aloalo Ray': 'Aloalo-Rochen',
        'Aloalo Snipper': 'Aloalo-Schnippler',
        'Aloalo Wood Golem': 'Aloalo-Holzgolem',
        'Aloalo Zaratan': 'Aloalo-Zaratan',
        'Arcane Font': 'arkan(?:e|er|es|en) KÃ¶rper',
        'Arcane Globe': 'arkan(?:e|er|es|en) Kugel',
        'Ball of Fire': 'Feuerkugel',
        'Bomb': 'Bombe',
        'Ketuduke': 'Ketuduke',
        'Lala': 'Lala',
        'Needle': 'Nadel',
        'Spring Crystal': 'Wasserquell-Kristall',
        'Statice': 'Statice',
        'Surprising Claw': 'Ãœberraschungsklaue',
        'Surprising Missile': 'Ãœberraschungsrakete',
        'Surprising Staff': 'Ãœberraschungsstab',
        'The Dawn Trial': 'Morgenrot-Probe',
        'The Dusk Trial': 'Abendrot-Probe',
        'The Midnight Trial': 'Vollmond-Probe',
      },
      'replaceText': {
        '\\(buff\\)': '(StatusverÃ¤nderung)',
        '\\(cast\\)': '(wirken)',
        'Aero II': 'Windra',
        'Aero IV': 'Windka',
        'Analysis': 'Analyse',
        'Angry Seas': 'Zornige Fluten',
        'Angular Addition': 'Winkeladdition',
        'Arcane Array': 'Arkanes Spektrum',
        'Arcane Blight': 'Arkane FÃ¤ule',
        'Arcane Mine': 'Arkane Mine',
        'Arcane Plot': 'Arkane Flur',
        'Arcane Point': 'Arkane StÃ¤tte',
        'Beguiling Glitter': 'Irrleuchten',
        'Blowing Bubbles': 'Pusteblasen',
        'Bright Pulse': 'GlÃ¼hen',
        'Bubble Net': 'Blasennetz',
        'Burning Chains': 'Brennende Ketten',
        'Burst': 'Explosion',
        'Constructive Figure': 'Ruf der SchÃ¶pfer',
        'Dartboard of Dancing Explosives': 'Darts und Drehung',
        'Encroaching Twintides': 'Ring der Zwiegezeiten',
        'Explosive Theorem': 'Arkane FÃ¤ule',
        'Faerie Ring': 'Feenring',
        'Far Tide': 'Ring der Gezeiten',
        'Fire Spread': 'Brandstiftung',
        'Fireworks': 'Feuerwerk',
        'Fluke Gale': 'Flossensturm',
        'Fluke Typhoon': 'Flossentaifun',
        'Hundred Lashings': 'Auspeitschung',
        'Hydrobomb': 'Hydro-Bombe',
        'Hydrobullet': 'Hydro-Kugel',
        'Hydrofall': 'Hydro-Sturz',
        'Inferno Divide': 'Infernale Teilung',
        'Inferno Theorem': 'Infernales Theorem',
        'Locked and Loaded': 'Geladen und entsichert',
        'Misload': 'Fehlladung',
        'Near Tide': 'Kreis der Gezeiten',
        'Pinwheeling Dartboard': 'Darts und Rad',
        'Planar Tactics': 'FlÃ¤chentaktiken',
        'Pop': 'Platzen',
        'Powerful Light': 'Entladenes Licht',
        'Present Box': 'Geschenkschachtel',
        'Radiance': 'Radiation',
        'Receding Twintides': 'Kreis der Zwiegezeiten',
        'Ring a Ring o\' Explosions': 'Ringel-Ringel-Bombe',
        '(?<! )Roar': 'BrÃ¼llen',
        'Saturate': 'WasserfontÃ¤ne',
        'Shocking Abandon': 'Schockende Hingabe',
        'Spatial Tactics': 'Raumtaktiken',
        'Sphere Shatter': 'SphÃ¤rensplitterung',
        'Spring Crystals': 'Quellkristalle',
        'Strategic Strike': 'Schwere Attacke',
        'Strewn Bubbles': 'Streublasen',
        'Surprise Balloon': 'Ãœberraschungsballon',
        'Surprise Needle': 'Ãœberraschungsnadel',
        'Symmetric Surge': 'Symmetrischer Schub',
        'Targeted Light': 'Gezieltes Licht',
        'Telluric Theorem': 'Tellurisches Theorem',
        'Tidal Roar': 'Schrei der Gezeiten',
        'Trapshooting': 'Tontaubenschuss',
        'Trick Reload': 'Trickladung',
        'Trigger Happy': 'SchieÃŸwut',
        'Uncommon Ground': 'Voll ins Schwarze',
        'Updraft': 'Aufwind',
      },
    },
    {
      'locale': 'fr',
      'replaceSync': {
        'Aloalo Golem': 'golem sylvestre d\'Aloalo',
        'Aloalo Islekeeper': 'gardien d\'Aloalo',
        'Aloalo Kiwakin': 'kiwakin d\'Aloalo',
        'Aloalo Monk': 'moine d\'Aloalo',
        'Aloalo Ray': 'raie rayÃ©e d\'Aloalo',
        'Aloalo Snipper': 'cisailleur d\'Aloalo',
        'Aloalo Wood Golem': 'golem sylvestre d\'Aloalo',
        'Aloalo Zaratan': 'zaratan d\'Aloalo',
        'Arcane Font': 'sphÃ¨re arcanique',
        'Arcane Globe': 'globe arcanique',
        'Ball of Fire': 'orbe de feu',
        'Bomb': 'bombe',
        'Ketuduke': 'Ketuduke',
        'Lala': 'Lala',
        'Needle': 'aiguille',
        'Spring Crystal': 'cristal de source',
        'Statice': 'Statice',
        'Surprising Claw': 'griffe surprise',
        'Surprising Missile': 'missile surprise',
        'Surprising Staff': 'sceptre surprise',
        'The Dawn Trial': 'Ã‰preuve de Dilumu',
        'The Dusk Trial': 'Ã‰preuve de Qurupe',
        'The Midnight Trial': 'Ã‰preuve de Nokosero',
      },
      'replaceText': {
        '\\(buff\\)': '(Buff)',
        '\\(cast\\)': '(Incantation)',
        'Aero II': 'Extra Vent',
        'Aero IV': 'Giga Vent',
        'Analysis': 'Analyse',
        'Angry Seas': 'Mer agitÃ©e',
        'Angular Addition': 'Calcul angulaire',
        'Arcane Array': 'Assemblement arcanique',
        'Arcane Blight': 'Canon arcanique',
        'Arcane Mine': 'Mine arcanique',
        'Arcane Plot': 'Modulateur arcanique',
        'Arcane Point': 'Pointe arcanique',
        'Beguiling Glitter': 'Paillettes aveuglantes',
        'Blowing Bubbles': 'Bulles soufflÃ©es',
        'Bright Pulse': 'Ã‰clat',
        'Bubble Net': 'Filet de bulles',
        'Burning Chains': 'ChaÃ®nes brÃ»lantes',
        'Burst': 'Explosion',
        'Constructive Figure': 'IcÃ´ne articulÃ©e',
        'Dartboard of Dancing Explosives': 'Duo flÃ©chettes-tourbillon',
        'Encroaching Twintides': 'Double marÃ©e dÃ©bordante',
        'Explosive Theorem': 'ThÃ©orÃ¨me explosif',
        'Faerie Ring': 'Cercle fÃ©Ã©rique',
        'Far Tide': 'MarÃ©e lointaine',
        'Fire Spread': 'Nappe de feu',
        'Fireworks': 'Feu d\'artifice',
        'Fluke Gale': 'Bourrasque hasardeuse',
        'Fluke Typhoon': 'Typhon hasardeux',
        'Hundred Lashings': 'Cent coups de fouet',
        'Hydrobomb': 'Hydrobombe',
        'Hydrobullet': 'Barillet hydrique',
        'Hydrofall': 'Pilonnage hydrique',
        'Inferno Divide': 'Division infernale',
        'Inferno Theorem': 'ThÃ©orÃ¨me infernal',
        'Locked and Loaded': 'Rechargement rÃ©ussi',
        'Misload': 'Rechargement ratÃ©',
        'Near Tide': 'MarÃ©e proche',
        'Pinwheeling Dartboard': 'Duo flÃ©chettes-moulinette',
        'Planar Tactics': 'Tactique planaire',
        'Pop': 'Rupture',
        'Powerful Light': 'Explosion sacrÃ©e',
        'Present Box': 'BoÃ®tes cadeaux',
        'Radiance': 'Irradiation',
        'Receding Twintides': 'Double marÃ©e fuyante',
        'Ring a Ring o\' Explosions': 'TempÃ©rament explosif',
        '(?<! )Roar': 'Rugissement',
        'Saturate': 'Jet d\'eau',
        'Shocking Abandon': 'Choc renonciateur',
        'Spatial Tactics': 'Tactique spatiale',
        'Sphere Shatter': 'Rupture glacÃ©e',
        'Spring Crystals': 'Cristaux de source',
        'Strategic Strike': 'Coup violent',
        'Strewn Bubbles': 'Bulles Ã©parpillÃ©es',
        'Surprise Balloon': 'Ballons surprises',
        'Surprise Needle': 'Aiguille surprise',
        'Symmetric Surge': 'DÃ©ferlement symÃ©trique',
        'Targeted Light': 'Rayon ciblÃ©',
        'Telluric Theorem': 'ThÃ©orÃ¨me tellurique',
        'Tidal Roar': 'Vague rugissante',
        'Trapshooting': 'Tir au pigeon',
        'Trick Reload': 'Rechargement habile',
        'Trigger Happy': 'GÃ¢chette impulsive',
        'Uncommon Ground': 'Terrain de mÃ©sentente',
        'Updraft': 'Courants ascendants',
      },
    },
    {
      'locale': 'ja',
      'replaceSync': {
        'Aloalo Golem': 'ã‚¢ãƒ­ã‚¢ãƒ­ãƒ»ã‚¦ãƒƒãƒ‰ã‚´ãƒ¼ãƒ¬ãƒ ',
        'Aloalo Islekeeper': 'ã‚¢ãƒ­ã‚¢ãƒ­ãƒ»ã‚­ãƒ¼ãƒ‘ãƒ¼',
        'Aloalo Kiwakin': 'ã‚¢ãƒ­ã‚¢ãƒ­ãƒ»ã‚­ãƒ¯ã‚­ãƒ³',
        'Aloalo Monk': 'ã‚¢ãƒ­ã‚¢ãƒ­ãƒ»ãƒ¢ãƒ³ã‚¯',
        'Aloalo Ray': 'ã‚¢ãƒ­ã‚¢ãƒ­ãƒ»ã‚¹ãƒˆãƒ©ã‚¤ãƒ—ãƒ¬ã‚¤',
        'Aloalo Snipper': 'ã‚¢ãƒ­ã‚¢ãƒ­ãƒ»ã‚¹ãƒ‹ãƒƒãƒ‘ãƒ¼',
        'Aloalo Wood Golem': 'ã‚¢ãƒ­ã‚¢ãƒ­ãƒ»ã‚¦ãƒƒãƒ‰ã‚´ãƒ¼ãƒ¬ãƒ ',
        'Aloalo Zaratan': 'ã‚¢ãƒ­ã‚¢ãƒ­ãƒ»ã‚¶ãƒ©ã‚¿ãƒ³',
        'Arcane Font': 'ç«‹ä½“é­”æ³•é™£',
        'Arcane Globe': 'çƒä½“é­”æ³•é™£',
        'Ball of Fire': 'ç«çƒ',
        'Bomb': 'çˆ†å¼¾',
        'Ketuduke': 'ã‚±ãƒˆã‚¥ãƒ‰ã‚¥ã‚±',
        'Lala': 'ãƒ©ãƒ©',
        'Needle': 'ãƒ‹ãƒ¼ãƒ‰ãƒ«',
        'Spring Crystal': 'æ¹§æ°´ã®ã‚¯ãƒªã‚¹ã‚¿ãƒ«',
        'Statice': 'ã‚¹ã‚¿ãƒ¼ãƒã‚¹',
        'Surprising Claw': 'ã‚µãƒ—ãƒ©ã‚¤ã‚ºãƒ»ã‚¯ãƒ­ãƒ¼',
        'Surprising Missile': 'ã‚µãƒ—ãƒ©ã‚¤ã‚ºãƒ»ãƒŸã‚µã‚¤ãƒ«',
        'Surprising Staff': 'ã‚µãƒ—ãƒ©ã‚¤ã‚ºãƒ»ãƒ­ãƒƒãƒ‰',
        'The Dawn Trial': 'ãƒ‡ã‚£ãƒ«ãƒ ã®è©¦ç·´',
        'The Dusk Trial': 'ã‚¯ãƒ«ãƒšã®è©¦ç·´',
        'The Midnight Trial': 'ãƒã‚³ã‚»ãƒ­ã®è©¦ç·´',
      },
      'replaceText': {
        '\\(buff\\)': '(ãƒãƒ•)',
        '\\(cast\\)': '(è© å”±)',
        'Aero II': 'ã‚¨ã‚¢ãƒ­ãƒ©',
        'Aero IV': 'ã‚¨ã‚¢ãƒ­ã‚¸ãƒ£',
        'Analysis': 'ã‚¢ãƒŠãƒ©ã‚¤ã‚º',
        'Angry Seas': 'ã‚¢ãƒ³ã‚°ãƒªãƒ¼ã‚·ãƒ¼ã‚º',
        'Angular Addition': 'å›è»¢è§’ä¹—ç®—',
        'Arcane Array': 'è¤‡åˆé­”ç´‹',
        'Arcane Blight': 'é­”ç´‹ç ²',
        'Arcane Mine': 'åœ°é›·é­”ç´‹',
        'Arcane Plot': 'å¤‰å…‰é­”ç´‹',
        'Arcane Point': 'å¤‰å…‰èµ·çˆ†',
        'Beguiling Glitter': 'æƒ‘ã‚ã—ã®å…‰',
        'Blowing Bubbles': 'ãƒãƒ–ãƒ«ãƒ–ãƒ­ãƒ¯ãƒ¼',
        'Bright Pulse': 'é–ƒå…‰',
        'Bubble Net': 'ãƒãƒ–ãƒ«ãƒãƒƒãƒˆãƒ•ã‚£ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°',
        'Burning Chains': 'ç‚ã®é–',
        'Burst': 'çˆ†ç™º',
        'Constructive Figure': 'äººå½¢å¬å–š',
        'Dartboard of Dancing Explosives': 'ãƒ€ãƒ¼ãƒ„ï¼†ãƒ­ãƒ¼ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³',
        'Encroaching Twintides': 'ãƒªãƒ³ã‚°ãƒ»ãƒ€ãƒ–ãƒ«ã‚¿ã‚¤ãƒ‰',
        'Explosive Theorem': 'é­”çˆ†æ³•',
        'Faerie Ring': 'ãƒ•ã‚§ã‚¢ãƒªãƒ¼ãƒªãƒ³ã‚°',
        'Far Tide': 'ãƒªãƒ³ã‚°ã‚¿ã‚¤ãƒ‰',
        'Fire Spread': 'æ”¾ç«',
        'Fireworks': 'ãƒ•ã‚¡ã‚¤ã‚¢ãƒ¯ãƒ¼ã‚¯ãƒ•ã‚§ã‚¹ãƒ†ã‚£ãƒãƒ«',
        'Fluke Gale': 'ãƒ•ãƒªãƒƒãƒ‘ãƒ¼ã‚²ã‚¤ãƒ«',
        'Fluke Typhoon': 'ãƒ•ãƒªãƒƒãƒ‘ãƒ¼ã‚¿ã‚¤ãƒ•ãƒ¼ãƒ³',
        'Hundred Lashings': 'ã‚ã£ãŸæ‰“ã¡',
        'Hydrobomb': 'ãƒã‚¤ãƒ‰ãƒ­ãƒœãƒ ',
        'Hydrobullet': 'ãƒã‚¤ãƒ‰ãƒ­ãƒãƒ¬ãƒƒãƒˆ',
        'Hydrofall': 'ãƒã‚¤ãƒ‰ãƒ­ãƒ•ã‚©ãƒ¼ãƒ«',
        'Inferno Divide': 'åç«æ³•',
        'Inferno Theorem': 'æ•£ç«æ³•',
        'Locked and Loaded': 'ãƒªãƒ­ãƒ¼ãƒ‰æˆåŠŸ',
        'Misload': 'ãƒªãƒ­ãƒ¼ãƒ‰å¤±æ•—',
        'Near Tide': 'ãƒ©ã‚¦ãƒ³ãƒ‰ã‚¿ã‚¤ãƒ‰',
        'Pinwheeling Dartboard': 'ãƒ€ãƒ¼ãƒ„ï¼†ã‚¦ã‚£ãƒ¼ãƒ«',
        'Planar Tactics': 'çˆ†é›·æˆ¦è¡“ï¼šé¢',
        'Pop': 'ç ´è£‚',
        'Powerful Light': 'å…‰çˆ†',
        'Present Box': 'ãƒ—ãƒ¬ã‚¼ãƒ³ãƒˆãƒœãƒƒã‚¯ã‚¹',
        'Radiance': 'å…‰çƒçˆ†æ•£',
        'Receding Twintides': 'ãƒ©ã‚¦ãƒ³ãƒ‰ãƒ»ãƒ€ãƒ–ãƒ«ã‚¿ã‚¤ãƒ‰',
        'Ring a Ring o\' Explosions': 'ãƒªãƒ³ã‚¯ãƒªãƒ³ã‚¯ãƒœãƒ ',
        '(?<! )Roar': 'å’†å“®',
        'Saturate': 'æ”¾æ°´',
        'Shocking Abandon': 'ã‚¢ãƒãƒ³ãƒ‰ãƒ³ã‚·ãƒ§ãƒƒã‚¯',
        'Spatial Tactics': 'çˆ†é›·æˆ¦è¡“ï¼šç«‹ä½“',
        'Sphere Shatter': 'ç ´è£‚',
        'Spring Crystals': 'æ¹§æ°´ã®ã‚¯ãƒªã‚¹ã‚¿ãƒ«',
        'Strategic Strike': 'å¼·æ’ƒ',
        'Strewn Bubbles': 'ãƒãƒ–ãƒ«ã‚¹ãƒˆã‚¥ãƒ«ãƒ¼',
        'Surprise Balloon': 'ã‚µãƒ—ãƒ©ã‚¤ã‚ºãƒãƒ«ãƒ¼ãƒ³',
        'Surprise Needle': 'ã‚µãƒ—ãƒ©ã‚¤ã‚ºãƒ‹ãƒ¼ãƒ‰ãƒ«',
        'Symmetric Surge': 'åŒæ•°çˆ†æ’ƒ',
        'Targeted Light': 'é«˜ç²¾åº¦å…‰å¼¾',
        'Telluric Theorem': 'åœ°éš†æ³•',
        'Tidal Roar': 'ã‚¿ã‚¤ãƒ€ãƒ«ãƒ­ã‚¢',
        'Trapshooting': 'ãƒˆãƒ©ãƒƒãƒ—ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°',
        'Trick Reload': 'ãƒˆãƒªãƒƒã‚¯ãƒªãƒ­ãƒ¼ãƒ‰',
        'Trigger Happy': 'ãƒˆãƒªã‚¬ãƒ¼ãƒãƒƒãƒ”ãƒ¼',
        'Uncommon Ground': 'ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã‚·ã‚¢ãƒ¼',
        'Updraft': 'ä¸Šæ˜‡æ°—æµ',
      },
    },
    {
      'locale': 'cn',
      'replaceSync': {
        'Aloalo Golem': 'é˜¿ç½—é˜¿ç½—æ ‘æœ¨å·¨åƒ',
        'Aloalo Islekeeper': 'é˜¿ç½—é˜¿ç½—å®ˆå«',
        'Aloalo Kiwakin': 'é˜¿ç½—é˜¿ç½—å¥‡ç“¦é‡‘',
        'Aloalo Monk': 'é˜¿ç½—é˜¿ç½—é¬¼é±¼',
        'Aloalo Ray': 'é˜¿ç½—é˜¿ç½—æ–‘é³',
        'Aloalo Snipper': 'é˜¿ç½—é˜¿ç½—åˆ©è¯é™†èŸ¹',
        'Aloalo Wood Golem': 'é˜¿ç½—é˜¿ç½—æ ‘æœ¨å·¨åƒ',
        'Aloalo Zaratan': 'é˜¿ç½—é˜¿ç½—æ‰æ‹‰å¦',
        'Arcane Font': 'ç«‹ä½“é­”æ³•é˜µ',
        'Arcane Globe': 'çƒä½“é­”æ³•é˜µ',
        'Ball of Fire': 'ç«çƒ',
        'Bomb': 'ç‚¸å¼¹',
        'Ketuduke': 'å‡¯å›¾å˜Ÿå‡¯',
        'Lala': 'æ‹‰æ‹‰é²',
        'Needle': 'é£é’ˆ',
        'Spring Crystal': 'æ¶Œæ°´æ°´æ™¶',
        'Statice': 'æ–¯å¡”ç¼‡ä¸',
        'Surprising Claw': 'æƒŠå–œçˆª',
        'Surprising Missile': 'æƒŠå–œå¯¼å¼¹',
        'Surprising Staff': 'æƒŠå–œæ–',
        'The Dawn Trial': 'æ›™è‰²çš„è¯•ç‚¼',
        'The Dusk Trial': 'æš®è‰²çš„è¯•ç‚¼',
        'The Midnight Trial': 'å¤œè‰²çš„è¯•ç‚¼',
      },
      'replaceText': {
        '\\(buff\\)': '(å¼ºåŒ–)',
        '\\(cast\\)': '(å’å”±)',
        'Aero II': 'çƒˆé£',
        'Aero IV': 'é£™é£',
        'Analysis': 'åˆ†æ',
        'Angry Seas': 'æ„¤æ€’ä¹‹æµ·',
        'Angular Addition': 'æ—‹è½¬è§’ä¹˜ç®—',
        'Arcane Array': 'å¤åˆé­”çº¹',
        'Arcane Blight': 'é­”çº¹ç‚®',
        'Arcane Mine': 'åœ°é›·é­”çº¹',
        'Arcane Plot': 'å˜å…‰é­”çº¹',
        'Arcane Point': 'å˜å…‰çˆ†ç‚¸',
        'Beguiling Glitter': 'å¹»æƒ‘ä¹‹å…‰',
        'Blowing Bubbles': 'å¹æ°”æ³¡',
        'Bright Pulse': 'é—ªå…‰',
        'Bubble Net': 'æ•é£Ÿæ°”æ³¡ç½‘',
        'Burning Chains': 'ç«ç„°é“¾',
        'Burst': 'çˆ†ç‚¸',
        'Constructive Figure': 'å¬å”¤äººå¶',
        'Dartboard of Dancing Explosives': 'é£é•–Â·ç‚¸å¼¹Â·è½¬è½¬è½¬',
        'Encroaching Twintides': 'ç¯æµªè¿æ½®',
        'Explosive Theorem': 'é­”çˆ†æ³•',
        'Faerie Ring': 'ä»™å¥³ç¯',
        'Far Tide': 'ç¯æµª',
        'Fire Spread': 'å–·ç«',
        'Fireworks': 'ç„°ç«å˜‰å¹´å',
        'Fluke Gale': 'é²¸å°¾çªé£',
        'Fluke Typhoon': 'é²¸å°¾å°é£',
        'Hundred Lashings': 'èƒ¡ä¹±æ‰“',
        'Hydrobomb': 'æ°´åŒ–çˆ†å¼¹',
        'Hydrobullet': 'æ°´åŒ–å¼¹',
        'Hydrofall': 'æ°´ç€‘',
        'Inferno Divide': 'åå­—ç«æ³•',
        'Inferno Theorem': 'æ•£ç«æ³•',
        'Locked and Loaded': 'è£…å¡«æˆåŠŸ',
        'Misload': 'è£…å¡«å¤±è´¥',
        'Near Tide': 'åœ†æµª',
        'Pinwheeling Dartboard': 'é£é•–Â·ç„°ç«Â·è½¬è½¬è½¬',
        'Planar Tactics': 'å¹³é¢çˆ†é›·æˆ˜æœ¯',
        'Pop': 'ç¢è£‚',
        'Powerful Light': 'å…‰çˆ†',
        'Present Box': 'ç¤¼ç‰©ç®±',
        'Radiance': 'å…‰çƒçˆ†ç‚¸',
        'Receding Twintides': 'åœ†æµªè¿æ½®',
        'Ring a Ring o\' Explosions': 'ç‚¸å¼¹è¿è¿çœ‹',
        '(?<! )Roar': 'å’†å“®',
        'Saturate': 'å–·æ°´',
        'Shocking Abandon': 'æ”¾çºµå†²å‡»',
        'Spatial Tactics': 'ç«‹ä½“çˆ†é›·æˆ˜æœ¯',
        'Sphere Shatter': 'ç¢è£‚',
        'Spring Crystals': 'æ¶Œæ°´æ°´æ™¶',
        'Strategic Strike': 'å¼ºå‡»',
        'Strewn Bubbles': 'æ•£å¸ƒæ°”æ³¡',
        'Surprise Balloon': 'æƒŠå–œæ°”çƒ',
        'Surprise Needle': 'æƒŠå–œé£é’ˆ',
        'Symmetric Surge': 'åŒæ•°çˆ†ç‚¸',
        'Targeted Light': 'é«˜ç²¾åº¦å…‰å¼¹',
        'Telluric Theorem': 'åœ°éš†æ³•',
        'Tidal Roar': 'æ€’æ½®å’†å“®',
        'Trapshooting': 'é™·é˜±å°„å‡»',
        'Trick Reload': 'èŠ±å¼è£…å¡«',
        'Trigger Happy': 'å¼€å¿ƒæ‰³æœº',
        'Uncommon Ground': 'ç›˜é¢æ”»å‡»',
        'Updraft': 'ä¸Šå‡æ°”æµ',
      },
    },
    {
      'locale': 'ko',
      'replaceSync': {
        'Aloalo Golem': 'ì•Œë¡œì•Œë¡œ ë‚˜ë¬´ê³¨ë ˜',
        'Aloalo Islekeeper': 'ì•Œë¡œì•Œë¡œ ì„¬ì§€í‚´ì´',
        'Aloalo Kiwakin': 'ì•Œë¡œì•Œë¡œ í‚¤ì™€í‚¨',
        'Aloalo Monk': 'ì•Œë¡œì•Œë¡œ ë¬¸ì–´',
        'Aloalo Ray': 'ì•Œë¡œì•Œë¡œ ì¤„ê°€ì˜¤ë¦¬',
        'Aloalo Snipper': 'ì•Œë¡œì•Œë¡œ ì‹¹ë‘‘ê²Œ',
        'Aloalo Wood Golem': 'ì•Œë¡œì•Œë¡œ ë‚˜ë¬´ê³¨ë ˜',
        'Aloalo Zaratan': 'ì•Œë¡œì•Œë¡œ ìë¼íƒ„',
        'Arcane Font': 'ì…ì²´ë§ˆë²•ì§„',
        'Arcane Globe': 'êµ¬ì²´ë§ˆë²•ì§„',
        'Ball of Fire': 'ë¶ˆë©ì´',
        'Bomb': 'í­íƒ„',
        'Ketuduke': 'ì¼€íˆ¬ë‘ì¼€',
        'Lala': 'ë„ë„',
        'Needle': 'ë°”ëŠ˜',
        'Spring Crystal': 'ìƒ˜ë¬¼ì˜ í¬ë¦¬ìŠ¤íƒˆ',
        'Statice': 'ìŠ¤íƒ€í‹°ìŠ¤',
        'Surprising Claw': 'ê¹œì§ ì†ì•„ê·€',
        'Surprising Missile': 'ê¹œì§ ë¯¸ì‚¬ì¼',
        'Surprising Staff': 'ê¹œì§ ì§€íŒ¡ì´',
        'The Dawn Trial': 'ë”œë£¨ë¬´ì˜ ì‹œë ¨',
        'The Dusk Trial': 'ì¿ ë£¨í˜ì˜ ì‹œë ¨',
        'The Midnight Trial': 'ë…¸ì½”ì„¸ë¡œì˜ ì‹œë ¨',
      },
      'replaceText': {
        '\\(buff\\)': '(ë””ë²„í”„)',
        '\\(cast\\)': '(ì‹œì „)',
        'Aero II': 'ì—ì–´ë¡œë¼',
        'Aero IV': 'ì—ì–´ë¡œìŸˆ',
        'Analysis': 'ë¶„ì„',
        'Angry Seas': 'ì„±ë‚œ ë°”ë‹¤',
        'Angular Addition': 'íšŒì „ê° ê°€ì‚°',
        'Arcane Array': 'ë³µí•© ë§ˆë²• ë¬¸ì–‘',
        'Arcane Blight': 'ë§ˆë²• ë¬¸ì–‘í¬',
        'Arcane Mine': 'ì§€ë¢° ë§ˆë²• ë¬¸ì–‘',
        'Arcane Plot': 'ë³€ê´‘ ë§ˆë²• ë¬¸ì–‘',
        'Arcane Point': 'ë³€ê´‘ ê¸°í­',
        'Beguiling Glitter': 'í™˜í˜¹ì˜ ë¹›',
        'Blowing Bubbles': 'ê±°í’ˆ ë°©ìš¸',
        'Bright Pulse': 'ì„¬ê´‘',
        'Bubble Net': 'ê±°í’ˆ ê·¸ë¬¼ íˆ¬ë§',
        'Burning Chains': 'í™”ì—¼ ì‚¬ìŠ¬',
        'Burst': 'ì‚°ì‚°ì¡°ê°',
        'Constructive Figure': 'ì¸í˜• ì†Œí™˜',
        'Dartboard of Dancing Explosives': 'ë‹¤íŠ¸ ëŒë¦¼íŒ',
        'Encroaching Twintides': 'ë¨¼ë°”ë‹¤ ì—°ì† í’ë‘',
        'Explosive Theorem': 'ë§ˆí­ë²•',
        'Faerie Ring': 'ìš”ì •ì˜ ê³ ë¦¬',
        'Far Tide': 'ë¨¼ë°”ë‹¤ í’ë‘',
        'Fire Spread': 'ë°©í™”',
        'Fireworks': 'í­ì£½ ì”ì¹˜',
        'Fluke Gale': 'ì§€ëŠëŸ¬ë¯¸ ëŒí’',
        'Fluke Typhoon': 'ì§€ëŠëŸ¬ë¯¸ íƒœí’',
        'Hundred Lashings': 'ë§ˆêµ¬ ë•Œë¦¬ê¸°',
        'Hydrobomb': 'ë¬¼í­íƒ„',
        'Hydrobullet': 'ë¬¼ì´ì•Œ',
        'Hydrofall': 'ë¬¼ ìŸê¸°',
        'Inferno Divide': 'ì‹­ìí™”ë²•',
        'Inferno Theorem': 'ì‚°í™”ë²•',
        'Locked and Loaded': 'ì¥ì „ ì„±ê³µ',
        'Misload': 'ì¥ì „ ì‹¤íŒ¨',
        'Near Tide': 'ì•ë°”ë‹¤ í’ë‘',
        'Pinwheeling Dartboard': 'ë‹¤íŠ¸ í­ì£½',
        'Planar Tactics': 'í­ë¢°ì „ìˆ : í‰ë©´',
        'Pop': 'íŒŒì—´',
        'Powerful Light': 'ë¹›ì˜ í­ë°œ',
        'Present Box': 'ì„ ë¬¼ìƒì',
        'Radiance': 'ë¹›êµ¬ìŠ¬ í­ë°œ',
        'Receding Twintides': 'ì•ë°”ë‹¤ ì—°ì† í’ë‘',
        'Ring a Ring o\' Explosions': 'ì—°ê²° í­íƒ„',
        '(?<! )Roar': 'í¬íš¨',
        'Saturate': 'ë¬¼ ë¿œê¸°',
        'Shocking Abandon': 'íˆ¬í•˜ ì¶©ê²©',
        'Spatial Tactics': 'í­ë¢°ì „ìˆ : ì…ì²´',
        'Sphere Shatter': 'íŒŒì—´',
        'Spring Crystals': 'ìƒ˜ë¬¼ì˜ í¬ë¦¬ìŠ¤íƒˆ',
        'Strategic Strike': 'ê°•ë ¥ ê³µê²©',
        'Strewn Bubbles': 'ê±°í’ˆ ìœ í¬',
        'Surprise Balloon': 'ê¹œì§ í’ì„ ',
        'Surprise Needle': 'ê¹œì§ ë°”ëŠ˜',
        'Symmetric Surge': 'ëŒ€ì¹­ í­ê²©',
        'Targeted Light': 'ê³ ì •ë°€ ê´‘íƒ„',
        'Telluric Theorem': 'ìœµê¸°ë²•',
        'Tidal Roar': 'ë°”ë‹¤ì˜ í¬íš¨',
        'Trapshooting': 'í•¨ì • ì‚¬ê²©',
        'Trick Reload': 'ìš”ìˆ  ì¥ì „',
        'Trigger Happy': 'ë§ˆêµ¬ì¡ì´ ë°œì‚¬',
        'Uncommon Ground': 'ê·¸ìŠ¬ë¦° ë•…',
        'Updraft': 'ìƒìŠ¹ ê¸°ë¥˜',
      },
    },
  ],
};

export default triggerSet;
